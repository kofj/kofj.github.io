[{"title":"Golang 用 gRPC 构建高性能 API","date":"2017-09-26T16:00:00.000Z","path":"2017/09/27/Golang用gRPC构建高性能API/","text":"&emsp;&emsp;作为拥有多年经验的软件开发者，我们都知道 API 在系统当中的重要性——它们无处不在，是应用程序的基石，定义着应用程序之间怎么样通讯。日益增进的技术，爆发式增长的用户需求都在不断的让我们需要构建更加性能的 API。 &emsp;&emsp;gRPC定义服务简便；夸语言、跨平台；快捷且可扩展；全双工通讯并内置认证。Golang 原生支持高并发；程序执行高效，语言设计优秀。&emsp;&emsp;gPRC 和 Golang 结合起来则能够让我们非常方便的开发出高性能的 API。 0x1 gRPC 与 Protocol Buffers 是什么&emsp;&emsp;RPC 是 Remote Procedure Call 的缩写，gRPC 是 Google 开源的 RPC 框架和库。gRPC 使用 Protocol Buffers 作为其序列化协议。 0x2 安装 gRPC 与 Protocol Buffers&emsp;&emsp;首先，我们安装 Protocol Buffers 的 Golang 插件：1go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125; &emsp;&emsp;接着， 安装 Protocol Buffers 工具。安装在 MacOS 上，我们可以通过 homebrew 来安装：1brew install protobuf 0x3 构建 API 服务&emsp;&emsp;本文以构建一个可以新建、通过 uid 查找用户的命令行交互程序为例来演示如何通过 gRPC 构建高性能的 API。所有代码访问 https://github.com/kofj/ggrpc 获得。项目代码结构如下： 12345678├── api│ └── users│ └── users.pb.go├── client│ └── client.go├── server│ └── server.go└── users.proto 定义服务与消息&emsp;&emsp;要使用 gRPC，我们需要先定义远程调用的服务和调用服务时传递的消息。gRPC 服务由 .proto 文件定义，并用于生成对应的 .pb.go。下列代码是定义好的 users.proto。12345678910111213141516171819202122232425262728293031syntax = &quot;proto3&quot;;package users;// Define the user service.service User &#123; // Get user info with filter. rpc GetUser (UserFilter) returns (stream UserInfo) &#123;&#125; // Create a new user. rpc CreateUser (UserInfo) returns (CreateUserState) &#123;&#125;&#125;message UserFilter &#123; int32 id = 1;&#125;message UserInfo &#123; int32 id = 1; string name = 2; string email = 3; message Phone &#123; string number = 1; bool isOffice = 2; &#125; repeated Phone Phones = 4;&#125;message CreateUserState &#123; int32 id = 1; bool success = 2;&#125; 生成 gPRC 代码&emsp;&emsp;定义好了服务和通讯消息，我们需要使用 Protocol Buffers 的协议编译工具 protoc 来编译生成对应的 .pb.go 文件。 1protoc users.proto --go_out=plugins=grpc:api/users &emsp;&emsp;通过上述命令，我们能编译生成得位于 api/users 文件夹的 users.pb.go 文件。这个文件包含了: 生成的服务端和客户端代码； 用于填充，序列化和检索我们 UserFilter、UserInfo 和 CreateUserState 消息类型的代码。 实现服务端程序&emsp;&emsp;users.pb.go 中的服务器代码是一个 Interface，具体的逻辑还需要我们自己来实现。 1234567891011121314151617181920212223242526// Users implement apiUsers.UserServer interface.type Users struct &#123; users []*apiUsers.UserInfo&#125;func (u *Users) GetUser(filter *apiUsers.UserFilter, stream apiUsers.User_GetUserServer) error &#123; log.Println(\"find user via id:\", filter.Id) for _, user := range u.users &#123; if filter.Id == user.Id &#123; err := stream.Send(user) if err != nil &#123; return err &#125; &#125; &#125; return nil&#125;func (u *Users) CreateUser(c context.Context, user *apiUsers.UserInfo) (state *apiUsers.CreateUserState, err error) &#123; user.Id = int32(len(u.users) + 1) u.users = append(u.users, user) log.Println(\"new user:\", user.Id) return &amp;apiUsers.CreateUserState&#123;Id: user.Id, Success: true&#125;, nil&#125;var _ apiUsers.UserServer = &amp;Users&#123;&#125; 实现客户端程序&emsp;&emsp;和服务端代码只是个 Interface 不同，users.pb.go 已经为我们实现了客户端代码。首先，连接服务器并创建客户端： 1234567// connect to gRPC serverconn, err := grpc.Dial(server, grpc.WithInsecure())if err != nil &#123; log.Fatal(\"cannot connect to server:\", err)&#125;defer conn.Close()client := apiUsers.NewUserClient(conn) &emsp;&emsp;接着，我们就可以直接调用服务器上的服务了：12345678910111213141516171819202122232425262728293031// Call CreateUser function on Server via gPRCfunc createUser(client apiUsers.UserClient, user *apiUsers.UserInfo) &#123; resp, err := client.CreateUser(context.Background(), user) if err != nil &#123; log.Println(\"Could not create user:\", err) return &#125; if resp.Success &#123; log.Println(\"A new user has been added, id:\", resp.Id) &#125;&#125;// Call GetUser function on Server via gPRCfunc findUser(client apiUsers.UserClient, uid int32) &#123; filter := &amp;apiUsers.UserFilter&#123;Id: uid&#125; stream, err := client.GetUser(context.Background(), filter) if err != nil &#123; log.Println(\"failed on get user info:\", err) return &#125; for &#123; user, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Printf(\"%v.GetPersons(_) = _, %v\", client, err) &#125; fmt.Println(user) &#125;&#125; 运行程序&emsp;&emsp;前文给出的只是代码片段，我们可以 clone 下完整的代码来运行。12git clone https://github.com/kofj/ggrpccd ggrpc &emsp;&emsp;启动服务器： 1go run server/server.go &emsp;&emsp;启动客户端： 1go run client/client.go 0x4 结语&emsp;&emsp;好了，到现在我们已经成功的构建了一个基于 gRPC 的 API。其性能真的更高吗？我们可以下次尝试与 HTTP REST 构建的 API 做一次性能对比实验。","content":"<p>&emsp;&emsp;作为拥有多年经验的软件开发者，我们都知道 API 在系统当中的重要性——它们无处不在，是应用程序的基石，定义着应用程序之间怎么样通讯。日益增进的技术，爆发式增长的用户需求都在不断的让我们需要构建更加性能的 API。</p>\n<p>&emsp;&emsp;gRPC定义服务简便；夸语言、跨平台；快捷且可扩展；全双工通讯并内置认证。Golang 原生支持高并发；程序执行高效，语言设计优秀。<br>&emsp;&emsp;gPRC 和 Golang 结合起来则能够让我们非常方便的开发出高性能的 API。<br><a id=\"more\"></a><br><img src=\"/accross_lang.png\" alt=\"gRPC\"></p>\n<h2 id=\"0x1-gRPC-与-Protocol-Buffers-是什么\"><a href=\"#0x1-gRPC-与-Protocol-Buffers-是什么\" class=\"headerlink\" title=\"0x1 gRPC 与 Protocol Buffers 是什么\"></a>0x1 gRPC 与 Protocol Buffers 是什么</h2><p>&emsp;&emsp;<code>RPC</code> 是 <code>Remote Procedure Call</code> 的缩写，<code>gRPC</code> 是 Google 开源的 RPC 框架和库。gRPC 使用 Protocol Buffers 作为其序列化协议。</p>\n<h2 id=\"0x2-安装-gRPC-与-Protocol-Buffers\"><a href=\"#0x2-安装-gRPC-与-Protocol-Buffers\" class=\"headerlink\" title=\"0x2 安装 gRPC 与 Protocol Buffers\"></a>0x2 安装 gRPC 与 Protocol Buffers</h2><p>&emsp;&emsp;首先，我们安装 Protocol Buffers 的 Golang 插件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;</div></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;接着， 安装 Protocol Buffers 工具。安装在 MacOS 上，我们可以通过 homebrew 来安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install protobuf</div></pre></td></tr></table></figure></p>\n<h2 id=\"0x3-构建-API-服务\"><a href=\"#0x3-构建-API-服务\" class=\"headerlink\" title=\"0x3 构建 API 服务\"></a>0x3 构建 API 服务</h2><p>&emsp;&emsp;本文以构建一个可以新建、通过 <strong>uid</strong> 查找用户的命令行交互程序为例来演示如何通过 <strong>gRPC</strong> 构建高性能的 API。所有代码访问 <a href=\"https://github.com/kofj/ggrpc\" target=\"_blank\" rel=\"external\">https://github.com/kofj/ggrpc</a> 获得。项目代码结构如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── api</div><div class=\"line\">│   └── users</div><div class=\"line\">│       └── users.pb.go</div><div class=\"line\">├── client</div><div class=\"line\">│   └── client.go</div><div class=\"line\">├── server</div><div class=\"line\">│   └── server.go</div><div class=\"line\">└── users.proto</div></pre></td></tr></table></figure>\n<h3 id=\"定义服务与消息\"><a href=\"#定义服务与消息\" class=\"headerlink\" title=\"定义服务与消息\"></a>定义服务与消息</h3><p>&emsp;&emsp;要使用 gRPC，我们需要先定义远程调用的服务和调用服务时传递的消息。gRPC 服务由 <code>.proto</code> 文件定义，并用于生成对应的 <code>.pb.go</code>。下列代码是定义好的 users.proto。<br><figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">syntax = &quot;proto3&quot;;</div><div class=\"line\"></div><div class=\"line\">package users;</div><div class=\"line\"></div><div class=\"line\">// Define the user service.</div><div class=\"line\">service User &#123;</div><div class=\"line\">    // Get user info with filter.</div><div class=\"line\">    rpc GetUser (UserFilter) returns (stream UserInfo) &#123;&#125;</div><div class=\"line\">    // Create a new user.</div><div class=\"line\">    rpc CreateUser  (UserInfo) returns (CreateUserState) &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">message UserFilter &#123;</div><div class=\"line\">    int32 id = 1;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">message UserInfo &#123;</div><div class=\"line\">    int32 id = 1;</div><div class=\"line\">    string name = 2;</div><div class=\"line\">    string email = 3;</div><div class=\"line\">    message Phone &#123;</div><div class=\"line\">        string number = 1;</div><div class=\"line\">        bool isOffice = 2;</div><div class=\"line\">    &#125;</div><div class=\"line\">    repeated Phone Phones = 4;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">message CreateUserState &#123;</div><div class=\"line\">    int32 id = 1;</div><div class=\"line\">    bool success = 2;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"生成-gPRC-代码\"><a href=\"#生成-gPRC-代码\" class=\"headerlink\" title=\"生成 gPRC 代码\"></a>生成 gPRC 代码</h3><p>&emsp;&emsp;定义好了服务和通讯消息，我们需要使用 Protocol Buffers 的协议编译工具 <code>protoc</code> 来编译生成对应的 <code>.pb.go</code> 文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">protoc  users.proto --go_out=plugins=grpc:api/users</div></pre></td></tr></table></figure>\n<p>&emsp;&emsp;通过上述命令，我们能编译生成得位于 <strong>api/users</strong> 文件夹的 <code>users.pb.go</code> 文件。这个文件包含了:</p>\n<ul>\n<li>生成的服务端和客户端代码；</li>\n<li>用于填充，序列化和检索我们 <code>UserFilter</code>、<code>UserInfo</code> 和 <code>CreateUserState</code> 消息类型的代码。</li>\n</ul>\n<h3 id=\"实现服务端程序\"><a href=\"#实现服务端程序\" class=\"headerlink\" title=\"实现服务端程序\"></a>实现服务端程序</h3><p>&emsp;&emsp;<code>users.pb.go</code> 中的服务器代码是一个 Interface，具体的逻辑还需要我们自己来实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Users implement apiUsers.UserServer interface.</span></div><div class=\"line\"><span class=\"keyword\">type</span> Users <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tusers []*apiUsers.UserInfo</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(u *Users)</span> <span class=\"title\">GetUser</span><span class=\"params\">(filter *apiUsers.UserFilter, stream apiUsers.User_GetUserServer)</span> <span class=\"title\">error</span></span> &#123;</div><div class=\"line\">\tlog.Println(<span class=\"string\">\"find user via id:\"</span>, filter.Id)</div><div class=\"line\">\t<span class=\"keyword\">for</span> _, user := <span class=\"keyword\">range</span> u.users &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> filter.Id == user.Id &#123;</div><div class=\"line\">\t\t\terr := stream.Send(user)</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> err</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(u *Users)</span> <span class=\"title\">CreateUser</span><span class=\"params\">(c context.Context, user *apiUsers.UserInfo)</span> <span class=\"params\">(state *apiUsers.CreateUserState, err error)</span></span> &#123;</div><div class=\"line\">\tuser.Id = <span class=\"keyword\">int32</span>(<span class=\"built_in\">len</span>(u.users) + <span class=\"number\">1</span>)</div><div class=\"line\">\tu.users = <span class=\"built_in\">append</span>(u.users, user)</div><div class=\"line\">\tlog.Println(<span class=\"string\">\"new user:\"</span>, user.Id)</div><div class=\"line\">\t<span class=\"keyword\">return</span> &amp;apiUsers.CreateUserState&#123;Id: user.Id, Success: <span class=\"literal\">true</span>&#125;, <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> _ apiUsers.UserServer = &amp;Users&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"实现客户端程序\"><a href=\"#实现客户端程序\" class=\"headerlink\" title=\"实现客户端程序\"></a>实现客户端程序</h3><p>&emsp;&emsp;和服务端代码只是个 Interface 不同，<code>users.pb.go</code> 已经为我们实现了客户端代码。首先，连接服务器并创建客户端：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// connect to gRPC server</span></div><div class=\"line\">conn, err := grpc.Dial(server, grpc.WithInsecure())</div><div class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\tlog.Fatal(<span class=\"string\">\"cannot connect to server:\"</span>, err)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">defer</span> conn.Close()</div><div class=\"line\">client := apiUsers.NewUserClient(conn)</div></pre></td></tr></table></figure>\n<p>&emsp;&emsp;接着，我们就可以直接调用服务器上的服务了：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Call CreateUser function on Server via gPRC</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createUser</span><span class=\"params\">(client apiUsers.UserClient, user *apiUsers.UserInfo)</span></span> &#123;</div><div class=\"line\">\tresp, err := client.CreateUser(context.Background(), user)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tlog.Println(<span class=\"string\">\"Could not create user:\"</span>, err)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span> resp.Success &#123;</div><div class=\"line\">\t\tlog.Println(<span class=\"string\">\"A new user has been added, id:\"</span>, resp.Id)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Call GetUser function on Server via gPRC</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findUser</span><span class=\"params\">(client apiUsers.UserClient, uid <span class=\"keyword\">int32</span>)</span></span> &#123;</div><div class=\"line\">\tfilter := &amp;apiUsers.UserFilter&#123;Id: uid&#125;</div><div class=\"line\">\tstream, err := client.GetUser(context.Background(), filter)</div><div class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\tlog.Println(<span class=\"string\">\"failed on get user info:\"</span>, err)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">for</span> &#123;</div><div class=\"line\">\t\tuser, err := stream.Recv()</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err == io.EOF &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">break</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">\t\t\tlog.Printf(<span class=\"string\">\"%v.GetPersons(_) = _, %v\"</span>, client, err)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfmt.Println(user)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"运行程序\"><a href=\"#运行程序\" class=\"headerlink\" title=\"运行程序\"></a>运行程序</h3><p>&emsp;&emsp;前文给出的只是代码片段，我们可以 clone 下完整的代码来运行。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/kofj/ggrpc</div><div class=\"line\"><span class=\"built_in\">cd</span> ggrpc</div></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;启动服务器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">go run server/server.go</div></pre></td></tr></table></figure>\n<p>&emsp;&emsp;启动客户端：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">go run client/client.go</div></pre></td></tr></table></figure>\n<h2 id=\"0x4-结语\"><a href=\"#0x4-结语\" class=\"headerlink\" title=\"0x4 结语\"></a>0x4 结语</h2><p>&emsp;&emsp;好了，到现在我们已经成功的构建了一个基于 gRPC 的 API。其性能真的更高吗？我们可以下次尝试与 <strong>HTTP REST</strong> 构建的 API 做一次性能对比实验。</p>\n","updated":"2017-09-28T10:09:37.000Z","excerpt":"&emsp;&emsp;作为拥有多年经验的软件开发者，我们都知道 API 在系统当中的重要性——它们无处不在，是应用程序的基石，定义着应用程序之间怎么样通讯。日益增进的技术，爆发式增长的用户需求都在不断的让我们需要构建更加性能的 API。 &emsp;&emsp;gRPC定义服务简便；夸语言、跨平台；快捷且可扩展；全双工通讯并内置认证。Golang 原生支持高并发；程序执行高效，语言设计优秀。&emsp;&emsp;gPRC 和 Golang 结合起来则能够让我们非常方便的开发出高性能的 API。","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"//blog.kongfanjian.com/tags/Golang/"},{"name":"gRPC","slug":"gRPC","permalink":"//blog.kongfanjian.com/tags/gRPC/"},{"name":"高性能","slug":"高性能","permalink":"//blog.kongfanjian.com/tags/高性能/"},{"name":"API","slug":"API","permalink":"//blog.kongfanjian.com/tags/API/"}]},{"title":"mount compressed tar file","date":"2017-09-26T16:00:00.000Z","path":"2017/09/27/mount-compressed-tar-file/","text":"123456789brew install archivemountarchivemount: OsxfuseRequirement unsatisfied!You can install with Homebrew-Cask: brew cask install osxfuseYou can download from: https://osxfuse.github.io/Error: An unsatisfied requirement failed this build. 1234567891011121314151617181920212223242526archivemount -husage: archivemount archivepath mountpoint [options]general options: -o opt,[opt...] mount options -h --help print help -V --version print versionarchivemount options: -o readonly disable write support -o nobackup remove archive file backups -o nosave do not save changes upon unmount. Good if you want to change something and save it as a diff, or use a format for saving which is not supported by archivemount. -o subtree=&lt;regexp&gt; use only subtree matching ^\\.\\?&lt;regexp&gt; from archive it implies readonlyFUSE options: -d -o debug enable debug output (implies -f) -f foreground operation -s disable multi-threaded operationfuse: no mount point","content":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">brew install archivemount</div><div class=\"line\">archivemount: OsxfuseRequirement unsatisfied!</div><div class=\"line\"></div><div class=\"line\">You can install with Homebrew-Cask:</div><div class=\"line\">  brew cask install osxfuse</div><div class=\"line\"></div><div class=\"line\">You can download from:</div><div class=\"line\">  https://osxfuse.github.io/</div><div class=\"line\">Error: An unsatisfied requirement failed this build.</div></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">archivemount -h</div><div class=\"line\">usage: archivemount archivepath mountpoint [options]</div><div class=\"line\"></div><div class=\"line\">general options:</div><div class=\"line\">    -o opt,[opt...]        mount options</div><div class=\"line\">    -h   --help            print help</div><div class=\"line\">    -V   --version         print version</div><div class=\"line\"></div><div class=\"line\">archivemount options:</div><div class=\"line\">    -o readonly            disable write support</div><div class=\"line\">    -o nobackup            remove archive file backups</div><div class=\"line\">    -o nosave              do not save changes upon unmount.</div><div class=\"line\">                           Good if you want to change something</div><div class=\"line\">                           and save it as a diff,</div><div class=\"line\">                           or use a format for saving which is</div><div class=\"line\">                           not supported by archivemount.</div><div class=\"line\"></div><div class=\"line\">    -o subtree=&lt;regexp&gt;    use only subtree matching ^\\.\\?&lt;regexp&gt; from archive</div><div class=\"line\">                           it implies readonly</div><div class=\"line\"></div><div class=\"line\">FUSE options:</div><div class=\"line\">    -d   -o debug          enable debug output (implies -f)</div><div class=\"line\">    -f                     foreground operation</div><div class=\"line\">    -s                     disable multi-threaded operation</div><div class=\"line\"></div><div class=\"line\">fuse: no mount point</div></pre></td></tr></table></figure>","updated":"2017-09-26T15:40:03.000Z","excerpt":"","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"mount","slug":"mount","permalink":"//blog.kongfanjian.com/tags/mount/"},{"name":"tar","slug":"tar","permalink":"//blog.kongfanjian.com/tags/tar/"},{"name":"奇巧淫技","slug":"奇巧淫技","permalink":"//blog.kongfanjian.com/tags/奇巧淫技/"}]},{"title":"强化扩展公钥——更安全的选择","date":"2017-09-26T15:11:40.000Z","path":"2017/09/26/强化扩展公钥——更安全的选择/","text":"&emsp;&emsp;想象一下这样的场景：在电商网站上，我们需要为每一个用户提供一个比特币的收款地址。如果使用传统的方法，我们需要通过私钥来产生公钥和地址，这使得我们不得不在服务器上部署私钥。但是世界上没有不透风的墙，任何人都不能保证绝对的安全，这么做简直和公开自己银行账户、密码无异。 &emsp;&emsp;当然，我们可以在安全的离线环境大批量的生成地址，然后导入到服务器的地址池中。这是个改善方案，但是不管你怎么设置地址池的大小，地址总归会有用完的一天，反复多次的生成、导入地址既不方便也不安全。 &emsp;&emsp;我们需要一个能够完全隔离公钥私钥，又能不断生成新的公钥与地址的方案。 &emsp;&emsp;使用分层确定密钥，我们可以通过 Kpar （父扩展公钥），cpar（父码链）加上子密钥索引号生成 Ki （子扩展公钥）和ci（子码链）。自此，我们可以不用在服务器上部署私钥来生成公钥了。这非常便于我们在不安全的环境下使用。 &emsp;&emsp;但是需要特别注意的是，如果知道了父扩展公钥和父扩展密钥衍生的任何非强化扩展私钥，就相当于知道了父扩展私钥，因而会泄露父扩展密钥衍生的所有扩展私钥。所以为了安全起见，从主密钥衍生扩展密钥的第一层开始就应该使用强化扩展密钥。 &emsp;&emsp;那么，什么是强化扩展密钥呢？每个扩展密钥能衍生出 2^31 个普通扩展密钥，2^31个强化扩展密钥。这些衍生出来的扩展密钥都有一个索引。 普通扩展密钥使用索引 0 到 2^31-1；强化扩展密钥使用索引 2^31 到 2^32-1。 &emsp;&emsp;请记住，在不安全的环境中一定要使用强化扩展公钥来生成子扩展公钥。","content":"<p>&emsp;&emsp;想象一下这样的场景：在电商网站上，我们需要为每一个用户提供一个比特币的收款地址。如果使用传统的方法，我们需要通过私钥来产生公钥和地址，这使得我们不得不在服务器上部署私钥。但是世界上没有不透风的墙，任何人都不能保证绝对的安全，这么做简直和公开自己银行账户、密码无异。</p>\n<a id=\"more\"></a>\n<p>&emsp;&emsp;当然，我们可以在安全的离线环境大批量的生成地址，然后导入到服务器的地址池中。这是个改善方案，但是不管你怎么设置地址池的大小，地址总归会有用完的一天，反复多次的生成、导入地址既不方便也不安全。</p>\n<p>&emsp;&emsp;我们需要一个能够完全隔离公钥私钥，又能不断生成新的公钥与地址的方案。</p>\n<p>&emsp;&emsp;使用分层确定密钥，我们可以通过 Kpar （父扩展公钥），cpar（父码链）加上子密钥索引号生成 Ki （子扩展公钥）和ci（子码链）。自此，我们可以不用在服务器上部署私钥来生成公钥了。这非常便于我们在不安全的环境下使用。</p>\n<p>&emsp;&emsp;但是需要特别注意的是，如果知道了父扩展公钥和父扩展密钥衍生的任何非强化扩展私钥，就相当于知道了父扩展私钥，因而会泄露父扩展密钥衍生的所有扩展私钥。所以为了安全起见，从主密钥衍生扩展密钥的第一层开始就应该使用强化扩展密钥。</p>\n<p>&emsp;&emsp;那么，什么是强化扩展密钥呢？每个扩展密钥能衍生出 2^31 个普通扩展密钥，2^31个强化扩展密钥。这些衍生出来的扩展密钥都有一个索引。 普通扩展密钥使用索引 0 到 2^31-1；<strong>强化扩展密钥使用索引 2^31 到 2^32-1</strong>。</p>\n<p>&emsp;&emsp;请记住，<strong>在不安全的环境中一定要使用强化扩展公钥来生成子扩展公钥。</strong></p>\n","updated":"2017-09-26T15:26:39.000Z","excerpt":"&emsp;&emsp;想象一下这样的场景：在电商网站上，我们需要为每一个用户提供一个比特币的收款地址。如果使用传统的方法，我们需要通过私钥来产生公钥和地址，这使得我们不得不在服务器上部署私钥。但是世界上没有不透风的墙，任何人都不能保证绝对的安全，这么做简直和公开自己银行账户、密码无异。","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"安全","slug":"安全","permalink":"//blog.kongfanjian.com/tags/安全/"},{"name":"密钥","slug":"密钥","permalink":"//blog.kongfanjian.com/tags/密钥/"}]},{"title":"OneNote 代码高亮","date":"2017-09-24T16:00:00.000Z","path":"2017/09/25/OneNote代码高亮/","text":"&emsp;&emsp;有言道『好记性不如烂笔头』。记笔记是个非常不错的习惯：一来可以帮助我们增强对笔记内容的记忆；二来则是可以在我们遗忘了的时候有处可查。多终端多平台同步能力以及对微软在办公领域专业性的信任，让我选择了 OneNote 作为主要的笔记软件。&emsp;&emsp;不过 OneNote 不支持代码高亮却是让人倍感遗憾。网上虽然有一些 OneNote 代码高亮的方法，但却复杂繁琐到让人望而却步。今天就来说说怎么样简单漂亮的在 OneNote 插入源代码。&emsp;&emsp;如果你恰巧是使用微软的 VSCode 作为代码的编辑器，那么恭喜——你能非常方便的解决这个问题了。不再废话——用 VSCode 打开你的源代码文件，选中→复制代码，然后直接在 OneNote 中粘贴，让我们看看效果怎么样： &emsp;&emsp;代码倒是高亮了，可是没那么清晰啊？这个也好解决：&emsp;&emsp; 1. 在 OneNote 页面中插入一个单元格；&emsp;&emsp; 2. 设置单元格底纹为黑色；&emsp;&emsp; 3. 粘贴从 VSCode 复制过来的源代码。 &emsp;&emsp;哇噢，效果好多了。从现在开始可以更加愉快的使用 OneNote 记笔记而不用换软件了。","content":"<p>&emsp;&emsp;有言道<strong>『好记性不如烂笔头』</strong>。记笔记是个非常不错的习惯：一来可以帮助我们增强对笔记内容的记忆；二来则是可以在我们遗忘了的时候有处可查。多终端多平台同步能力以及对微软在办公领域专业性的信任，让我选择了 OneNote 作为主要的笔记软件。<br>&emsp;&emsp;不过 OneNote 不支持代码高亮却是让人倍感遗憾。网上虽然有一些 OneNote 代码高亮的方法，但却复杂繁琐到让人望而却步。今天就来说说<strong>怎么样简单漂亮的在 OneNote 插入源代码</strong>。<br><a id=\"more\"></a><br>&emsp;&emsp;如果你恰巧是使用微软的 VSCode 作为代码的编辑器，那么恭喜——你能非常方便的解决这个问题了。不再废话——<strong>用 VSCode 打开你的源代码文件，选中→复制代码，然后直接在 OneNote 中粘贴</strong>，让我们看看效果怎么样：</p>\n<p><img src=\"/images/2017-09-25-17-22-35.png\" alt=\"\"></p>\n<p>&emsp;&emsp;代码倒是高亮了，可是没那么清晰啊？这个也好解决：<br>&emsp;&emsp; 1. 在 OneNote 页面中插入一个单元格；<br>&emsp;&emsp; 2. 设置单元格底纹为黑色；<br>&emsp;&emsp; 3. 粘贴从 VSCode 复制过来的源代码。</p>\n<p><img src=\"/images/2017-09-25-17-27-30.png\" alt=\"源代码黑色底纹\"><br>&emsp;&emsp;哇噢，效果好多了。从现在开始可以更加愉快的使用 OneNote 记笔记而不用换软件了。</p>\n","updated":"2017-09-25T15:44:06.000Z","excerpt":"&emsp;&emsp;有言道『好记性不如烂笔头』。记笔记是个非常不错的习惯：一来可以帮助我们增强对笔记内容的记忆；二来则是可以在我们遗忘了的时候有处可查。多终端多平台同步能力以及对微软在办公领域专业性的信任，让我选择了 OneNote 作为主要的笔记软件。&emsp;&emsp;不过 OneNote 不支持代码高亮却是让人倍感遗憾。网上虽然有一些 OneNote 代码高亮的方法，但却复杂繁琐到让人望而却步。今天就来说说怎么样简单漂亮的在 OneNote 插入源代码。","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"OneNote","slug":"OneNote","permalink":"//blog.kongfanjian.com/tags/OneNote/"},{"name":"高亮","slug":"高亮","permalink":"//blog.kongfanjian.com/tags/高亮/"},{"name":"笔记","slug":"笔记","permalink":"//blog.kongfanjian.com/tags/笔记/"},{"name":"微软","slug":"微软","permalink":"//blog.kongfanjian.com/tags/微软/"}]},{"title":"小米高管一言鸣条破块","date":"2017-09-24T10:44:31.000Z","path":"2017/09/24/小米高管一言鸣条破块/","text":"&emsp;&emsp;今天，有人问我对『小米校招涉日语专业歧视，学生要求道歉』这事儿怎么看时，本身对小米有不错观感的我感到万分不解——小米作为一家颇有影响力的大型公司会干这种蠢事？在看了新闻后，顿时觉得不足为奇了。&emsp;&emsp;首先，这事儿是小米高管在『校招』这种公开场合上的言论，其造成的影响不论好坏自然会被归结到『小米』这个品牌形象上。 &emsp;&emsp;理性的来说，公司的一个高管并不能完全代表公司的品牌形象，更何况这位也非小米的灵魂人物。 &emsp;&emsp;说完好话说丑话，小米是存在用人过错的。我不知道小米的高管培训有没有，是怎么样的。但是我认为，每个公司都有义务教育自己的员工，尤其是会在公众场合发言的高管——你的一言一行不仅仅是代表着你个人的，还会影响其它人对我们整个公司、员工的评价。 &emsp;&emsp;继续说这事儿本身，有人说认为这是专业歧视是太过敏感。敏感吗？不敏感，因为事儿没有落到您个身上。还有朋友说想歪了的人思想龌龊，对此我只能引用 @朱伟 的说法来回应： 目光短浅，让人家学日语的去拍电影，日本哪类电影非常盛名你我都心知肚明，容易把大家都吸引到一个地方去想，自己说话没有一杆衡量的秤，还是一个公司领导？ &emsp;&emsp;今天日语专业的可以去拍『电影』，你计算机专业的是不是就可以去当骇客做贼偷东西了？ &emsp;&emsp;不分场合，不分轻重胡言乱语必然会成为哗众取宠的小丑。不要把丑恶当幽默，不要借玩笑知名掩盖自己伤害他人的过失。 &emsp;&emsp;人非圣贤孰能无过，犯错了不逃避，不遮掩，用行动去弥补所犯过的过错，亦能让人称赞。 &emsp;&emsp;类似小米这样的事件总是层出不穷，让人不得不哀叹，我们这是怎么了？我认为，犯错不可怕，可怕的是我们犯错了不承认错误，不改正错误，用笑话、平时为人、分不清轻重为借口去逃避去否认。作为一个拥有完全行为能力的人，我们必须要为自己的一言一行负责任，应该谨言慎行，更应该『见贤思齐焉，见不贤而内自省也』。","content":"<p>&emsp;&emsp;今天，有人问我对『小米校招涉日语专业歧视，学生要求道歉』这事儿怎么看时，本身对小米有不错观感的我感到万分不解——小米作为一家颇有影响力的大型公司会干这种蠢事？在看了新闻后，顿时觉得不足为奇了。<br><a id=\"more\"></a><br>&emsp;&emsp;首先，这事儿是小米高管在『校招』这种公开场合上的言论，其造成的影响不论好坏自然会被归结到『小米』这个品牌形象上。</p>\n<p>&emsp;&emsp;理性的来说，公司的一个高管并不能完全代表公司的品牌形象，更何况这位也非小米的灵魂人物。</p>\n<p>&emsp;&emsp;说完好话说丑话，小米是存在用人过错的。我不知道小米的高管培训有没有，是怎么样的。但是我认为，每个公司都有义务教育自己的员工，尤其是会在公众场合发言的高管——你的一言一行不仅仅是代表着你个人的，还会影响其它人对我们整个公司、员工的评价。</p>\n<p>&emsp;&emsp;继续说这事儿本身，有人说认为这是专业歧视是太过敏感。敏感吗？不敏感，因为事儿没有落到您个身上。还有朋友说想歪了的人思想龌龊，对此我只能引用 <strong>@朱伟</strong> 的说法来回应：</p>\n<blockquote>\n<p>目光短浅，让人家学日语的去拍电影，日本哪类电影非常盛名你我都心知肚明，容易把大家都吸引到一个地方去想，自己说话没有一杆衡量的秤，还是一个公司领导？</p>\n</blockquote>\n<p>&emsp;&emsp;今天日语专业的可以去拍『电影』，你计算机专业的是不是就可以去当骇客做贼偷东西了？</p>\n<p>&emsp;&emsp;不分场合，不分轻重胡言乱语必然会成为哗众取宠的小丑。不要把丑恶当幽默，不要借玩笑知名掩盖自己伤害他人的过失。</p>\n<p>&emsp;&emsp;人非圣贤孰能无过，犯错了不逃避，不遮掩，用行动去弥补所犯过的过错，亦能让人称赞。</p>\n<p>&emsp;&emsp;类似小米这样的事件总是层出不穷，让人不得不哀叹，我们这是怎么了？我认为，犯错不可怕，可怕的是我们犯错了不承认错误，不改正错误，用笑话、平时为人、分不清轻重为借口去逃避去否认。作为一个拥有完全行为能力的人，我们必须要为自己的一言一行负责任，应该<strong>谨言慎行</strong>，更应该<strong>『见贤思齐焉，见不贤而内自省也』</strong>。</p>\n","updated":"2017-09-24T11:46:16.000Z","excerpt":"&emsp;&emsp;今天，有人问我对『小米校招涉日语专业歧视，学生要求道歉』这事儿怎么看时，本身对小米有不错观感的我感到万分不解——小米作为一家颇有影响力的大型公司会干这种蠢事？在看了新闻后，顿时觉得不足为奇了。","categories":[{"name":"浮生","slug":"浮生","permalink":"//blog.kongfanjian.com/categories/浮生/"}],"tags":[{"name":"自省","slug":"自省","permalink":"//blog.kongfanjian.com/tags/自省/"},{"name":"谨言慎行","slug":"谨言慎行","permalink":"//blog.kongfanjian.com/tags/谨言慎行/"},{"name":"公众形象","slug":"公众形象","permalink":"//blog.kongfanjian.com/tags/公众形象/"}]},{"title":"分层确定密钥及 Golang 实现","date":"2017-09-24T02:43:38.000Z","path":"2017/09/24/Hierarchical-deterministic-keys/","text":"&emsp;&emsp;本文三章节分别讲述 分层确定密钥 的起源、基本原理、程序实现。前两节面向所有人科普，第三节需要阅读者掌握 Go 编程语言。阅读全文预计需要 3-5 分钟，感谢 Tinvee 帮助审阅。 &emsp;&emsp;分层确定密钥(Hierarchical Deterministic keys) 是一种应用在比特币系统中的密钥管理技术，源自于 BIP32 分层确定性钱包。使用分层确定密钥可以帮助用户更加方便的备份、找回自己的密钥串。 0x1 分层确定性密钥——应运而生&emsp;&emsp;比特币钱包中保存的是一系列的 &lt;地址, 私钥&gt; 对；地址通过 Base58(Hash(公钥)) 算法计算得出；私钥是一个随机数，是用于控制地址上存储的比特币的唯一凭证。所以，安全便捷的管理、备份私钥尤其重要。&emsp;&emsp;但是，早期的比特币钱包被称为不确定性钱包，备份私钥并不方便。其中的私钥都是随机生成的，私钥之间没有任何关联。BIP32 的贡献开发者 Eric Lombrozo 指出 Bitcoin Core 初始钱包的密钥管理非常复杂： 当新地址生成的时候，你必须不断备份钱包，以此来保证安全，这种方式非常烦人。 &emsp;&emsp;如果个用户使用的是不确定性钱包，并且没有及时备份私钥，一旦私钥遗失，那他就永远失去了对应的比特币。人们迫切需要一种安全并更便捷的方案来备份自己的私钥，BIP32 协议应运而生，其核心技术便是分层确定密钥。 0x2 「道生一，一生二，二生三，三生万物」&emsp;&emsp;分层确定密钥 首先需要生成一个随机数当做种子（Seed），用于创建 确定性密钥链。然后由种子通过 单项离散方程（哈希） 算法得出 主密钥，主密钥再使用自身和子密钥索引（子密钥序号）生成 子密钥， 继而由 子密钥 生成 孙密钥，逐层生子成密钥，无穷无尽的密钥呈现出树形结构。 0x3 术&emsp;&emsp;讲完基本原理，接下来我们使用 Go 语言的 bitgoin/address 包来实现确定分层密钥。 &emsp;&emsp;首先，生成随机数作为种子：&emsp;&emsp;接着，使用种子生成主密钥：&emsp;&emsp;然后，逐层生成子密钥（示例只生成一层）：&emsp;&emsp;完整示例源代码如下：&emsp;&emsp;示例运行结果如下：","content":"<p>&emsp;&emsp;本文三章节分别讲述 <code>分层确定密钥</code> 的起源、基本原理、程序实现。前两节面向所有人科普，第三节需要阅读者掌握 Go 编程语言。阅读全文预计需要 3-5 分钟，感谢 <strong>Tinvee</strong> 帮助审阅。</p>\n<p>&emsp;&emsp;<code>分层确定密钥</code>(Hierarchical Deterministic keys) 是一种应用在比特币系统中的密钥管理技术，源自于 <strong><a href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\" target=\"_blank\" rel=\"external\">BIP32 分层确定性钱包</a></strong>。使用<code>分层确定密钥</code>可以帮助用户更加方便的备份、找回自己的密钥串。<br><a id=\"more\"></a></p>\n<h3 id=\"0x1-分层确定性密钥——应运而生\"><a href=\"#0x1-分层确定性密钥——应运而生\" class=\"headerlink\" title=\"0x1 分层确定性密钥——应运而生\"></a>0x1 分层确定性密钥——应运而生</h3><p>&emsp;&emsp;比特币钱包中保存的是一系列的 <strong>&lt;地址, 私钥&gt;</strong> 对；地址通过 <strong>Base58(Hash(公钥))</strong> 算法计算得出；私钥是一个随机数，是用于控制地址上存储的比特币的<strong>唯一凭证</strong>。所以，安全便捷的管理、备份私钥尤其重要。<br>&emsp;&emsp;但是，早期的比特币钱包被称为<strong>不确定性钱包</strong>，备份私钥并不方便。其中的私钥都是随机生成的，私钥之间没有任何关联。BIP32 的贡献开发者 Eric Lombrozo 指出 Bitcoin Core 初始钱包的密钥管理非常复杂：</p>\n<blockquote>\n<p>当新地址生成的时候，你必须不断备份钱包，以此来保证安全，这种方式非常烦人。</p>\n</blockquote>\n<p>&emsp;&emsp;如果个用户使用的是<strong>不确定性钱包</strong>，并且没有及时备份私钥，一旦私钥遗失，那他就永远失去了对应的比特币。人们迫切需要一种安全并更便捷的方案来备份自己的私钥，BIP32 协议应运而生，其核心技术便是<code>分层确定密钥</code>。</p>\n<h3 id=\"0x2-「道生一，一生二，二生三，三生万物」\"><a href=\"#0x2-「道生一，一生二，二生三，三生万物」\" class=\"headerlink\" title=\"0x2 「道生一，一生二，二生三，三生万物」\"></a>0x2 「道生一，一生二，二生三，三生万物」</h3><p>&emsp;&emsp;<code>分层确定密钥</code> 首先需要生成一个随机数当做种子（Seed），用于创建 <code>确定性密钥链</code>。然后由种子通过 <strong><code>单项离散方程</code></strong>（哈希） 算法得出 <code>主密钥</code>，主密钥再使用自身和子密钥索引（子密钥序号）生成 <code>子密钥</code>， 继而由 <code>子密钥</code> 生成 <code>孙密钥</code>，逐层生子成密钥，无穷无尽的密钥呈现出树形结构。<br><img src=\"/images/2017-09-24-12-47-25.png\" alt=\"种子生成密钥\"></p>\n<h3 id=\"0x3-术\"><a href=\"#0x3-术\" class=\"headerlink\" title=\"0x3 术\"></a>0x3 术</h3><p>&emsp;&emsp;讲完基本原理，接下来我们使用 Go 语言的 <a href=\"github.com/bitgoin/address\">bitgoin/address</a> 包来实现<code>确定分层密钥</code>。</p>\n<p>&emsp;&emsp;首先，生成随机数作为种子：<br><img src=\"/images/2017-09-24-13-49-37.png\" alt=\"\"><br>&emsp;&emsp;接着，使用种子生成主密钥：<br><img src=\"/images/2017-09-24-13-50-10.png\" alt=\"\"><br>&emsp;&emsp;然后，逐层生成子密钥（示例只生成一层）：<br><img src=\"/images/2017-09-24-13-50-37.png\" alt=\"\"><br>&emsp;&emsp;完整示例源代码如下：<br><img src=\"/images/2017-09-24-13-48-48.png\" alt=\"\"><br>&emsp;&emsp;示例运行结果如下：<br><img src=\"/images/2017-09-24-13-51-24.png\" alt=\"\"></p>\n","updated":"2017-09-24T11:35:20.000Z","excerpt":"&emsp;&emsp;本文三章节分别讲述 分层确定密钥 的起源、基本原理、程序实现。前两节面向所有人科普，第三节需要阅读者掌握 Go 编程语言。阅读全文预计需要 3-5 分钟，感谢 Tinvee 帮助审阅。 &emsp;&emsp;分层确定密钥(Hierarchical Deterministic keys) 是一种应用在比特币系统中的密钥管理技术，源自于 BIP32 分层确定性钱包。使用分层确定密钥可以帮助用户更加方便的备份、找回自己的密钥串。","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"golang","slug":"golang","permalink":"//blog.kongfanjian.com/tags/golang/"},{"name":"Hierarchical Deterministic","slug":"Hierarchical-Deterministic","permalink":"//blog.kongfanjian.com/tags/Hierarchical-Deterministic/"},{"name":"keys","slug":"keys","permalink":"//blog.kongfanjian.com/tags/keys/"}]},{"title":"说说CAA记录","date":"2017-09-09T14:59:50.000Z","path":"2017/09/09/talk-about-CAA/","text":"&emsp;&emsp;自2017年9月9日起，所有的 CA 在签发域名证书的时候都必须要检查 CAA DNS 记录。自此，域名所有者可以控制由哪些 CA 给持有的域名签发证书。 0x1 什么是 CAA DNS 记录？&emsp;&emsp;CAA 是 Certificate Authority Authorization（CA 授权）的缩写，是一种用于授权指定 CA 为你的域名和子域名签发证书的特殊 DNS 记录。&emsp;&emsp;CAA 可以让 CA 在收到新证书签发请求的时候通过邮件向你发送警报。CAA 记录有三种类型：issue，issuewild 和 iodef，更多详细内容可以阅读 CAA官方标准文档：https://tools.ietf.org/html/rfc6844 。 0x2 如果我的域名没有 CAA 记录，是否还能正常签发证书？&emsp;&emsp;能，答案是肯定的。所有的 CA 都必须检查 CAA 记录，但是，如果没有 CAA 记录的话，等同于任意 CA 都可以为你的域名签发证书。当然，CA 依然会在实际签发证书前做所有的验证。","content":"<p>&emsp;&emsp;自2017年9月9日起，所有的 CA 在签发域名证书的时候都必须要检查 CAA DNS 记录。自此，域名所有者可以控制由哪些 CA 给持有的域名签发证书。</p>\n<h3 id=\"0x1-什么是-CAA-DNS-记录？\"><a href=\"#0x1-什么是-CAA-DNS-记录？\" class=\"headerlink\" title=\"0x1 什么是 CAA DNS 记录？\"></a>0x1 什么是 CAA DNS 记录？</h3><p>&emsp;&emsp;CAA 是  <code>Certificate Authority Authorization</code>（CA 授权）的缩写，是一种用于授权指定 CA 为你的域名和子域名签发证书的特殊 DNS 记录。<br>&emsp;&emsp;CAA 可以让 CA 在收到新证书签发请求的时候通过邮件向你发送警报。CAA 记录有三种类型：<code>issue</code>，<code>issuewild</code> 和 <code>iodef</code>，更多详细内容可以阅读 <a href=\"https://tools.ietf.org/html/rfc6844\" target=\"_blank\" rel=\"external\">CAA官方标准文档</a>：<a href=\"https://tools.ietf.org/html/rfc6844\" target=\"_blank\" rel=\"external\">https://tools.ietf.org/html/rfc6844</a> 。</p>\n<h3 id=\"0x2-如果我的域名没有-CAA-记录，是否还能正常签发证书？\"><a href=\"#0x2-如果我的域名没有-CAA-记录，是否还能正常签发证书？\" class=\"headerlink\" title=\"0x2 如果我的域名没有 CAA 记录，是否还能正常签发证书？\"></a>0x2 如果我的域名没有 CAA 记录，是否还能正常签发证书？</h3><p>&emsp;&emsp;能，答案是肯定的。所有的 CA 都必须检查 CAA 记录，但是，如果没有 CAA 记录的话，等同于任意 CA 都可以为你的域名签发证书。当然，CA 依然会在实际签发证书前做所有的验证。</p>\n","updated":"2017-09-09T15:47:09.000Z","excerpt":"","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"DNS","slug":"DNS","permalink":"//blog.kongfanjian.com/tags/DNS/"},{"name":"CAA","slug":"CAA","permalink":"//blog.kongfanjian.com/tags/CAA/"}]},{"title":"GO run multiple files without test","date":"2017-08-31T02:43:39.000Z","path":"2017/08/31/GO-run-multiple-files-without-test/","text":"&emsp;&emsp;I am writing a project which has multiple files in the main package, after run go run *.go, I get this assert: go run: cannot run *_test.go files (shortener_test.go) &emsp;&emsp;WTF?! So I search Google and get this suggestion: 1go build &amp;&amp; ./&lt;executable&gt; &emsp;&emsp;I don’t think this one is a good solution, so I find another one: 1go run !(*_test).go &emsp;&emsp;Wow, this one is perfect!","content":"<p>&emsp;&emsp;I am writing a project which has multiple files in the main package, after run <code>go run *.go</code>, I get this assert:</p>\n<blockquote>\n<p>go run: cannot run *_test.go files (shortener_test.go)</p>\n</blockquote>\n<p>&emsp;&emsp;WTF?! So I search Google and get this suggestion:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">go build &amp;&amp; ./&lt;executable&gt;</div></pre></td></tr></table></figure>\n<p>&emsp;&emsp;I don’t think this one is a good solution, so I find another one:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">go run !(*_test).go</div></pre></td></tr></table></figure>\n<p>&emsp;&emsp;Wow, this one is perfect!</p>\n","updated":"2017-08-31T03:31:39.000Z","excerpt":"","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"//blog.kongfanjian.com/tags/Golang/"},{"name":"skill","slug":"skill","permalink":"//blog.kongfanjian.com/tags/skill/"}]},{"title":"我的男朋友被暴风音影杀了祭天","date":"2017-08-26T11:26:32.000Z","path":"2017/08/26/my-boyfriend-has-been-kill-by-his-company/","text":"&emsp;&emsp;最近，暴风影音在 Apple App Store 中国大陆版本更新中声称『修复了闪退的 bug，还杀了一个程序员祭天』。 &emsp;&emsp;刚看到这条消息的时候，我对此不以为意。但是，有些朋友告诉我，同样作为程序员，暴风影音这样写公告让他们感觉到了不适。紧接着，网上出现了对表示不适的朋友的指责声：&emsp;&emsp;『你们真是玻璃心啊！』&emsp;&emsp;『开个玩笑而已，有什么大不了的。』&emsp;&emsp;『这样就生气啦？你这人怎么这么开不起玩笑？说你 XXX 怎么了，多大点事！』&emsp;&emsp;没错，开始的时候可能仅仅是一句玩笑，说的多了，也可能成真。我想，没谁愿意自己的亲人独自哭诉：『我的某某被他们公司杀了祭天』。&emsp;&emsp;暴风影音作为一家拥有海量普通用户的互联网公司，在面向公众的平台上发布了针对特定群体的歧视性的，误导用户认知，并且宣扬暴力的内容。往大了说这种行为不仅仅是某些群体感到不适，而是会真真正正的影响社会团结，不应该被纵容。暴风影音欠所有人一个认真、诚意的致歉。&emsp;&emsp;今天也许只是针对程序员，明天呢？也许就是你所做的工作。我不希望自己的朋友们因为工作被歧视，甚至被当成牲畜般宰杀掉，即使是在笑话里。&emsp;&emsp;愿你的人生永远开得起玩笑。","content":"<p>&emsp;&emsp;最近，暴风影音在 Apple App Store 中国大陆版本更新中声称『修复了闪退的 bug，还杀了一个程序员祭天』。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6816152bly1fixcazzsq8j20c80lqjsy\" alt=\"我的男朋友被暴风音影杀了祭天\"></p>\n<p>&emsp;&emsp;刚看到这条消息的时候，我对此不以为意。但是，有些朋友告诉我，同样作为程序员，暴风影音这样写公告让他们感觉到了不适。紧接着，网上出现了对表示不适的朋友的指责声：<br>&emsp;&emsp;『你们真是玻璃心啊！』<br>&emsp;&emsp;『开个玩笑而已，有什么大不了的。』<br>&emsp;&emsp;『这样就生气啦？你这人怎么这么开不起玩笑？说你 XXX 怎么了，多大点事！』<br>&emsp;&emsp;没错，开始的时候可能仅仅是一句玩笑，说的多了，也可能成真。我想，没谁愿意自己的亲人独自哭诉：『我的某某被他们公司杀了祭天』。<br>&emsp;&emsp;暴风影音作为一家拥有海量普通用户的互联网公司，在面向公众的平台上发布了针对特定群体的歧视性的，误导用户认知，并且宣扬暴力的内容。往大了说这种行为不仅仅是某些群体感到不适，而是会真真正正的影响社会团结，不应该被纵容。暴风影音欠所有人一个认真、诚意的致歉。<br>&emsp;&emsp;今天也许只是针对程序员，明天呢？也许就是你所做的工作。我不希望自己的朋友们因为工作被歧视，甚至被当成牲畜般宰杀掉，即使是在笑话里。<br>&emsp;&emsp;愿你的人生永远开得起玩笑。</p>\n","updated":"2017-08-27T11:32:02.000Z","excerpt":"","categories":[{"name":"浮生","slug":"浮生","permalink":"//blog.kongfanjian.com/categories/浮生/"}],"tags":[{"name":"暴风音影","slug":"暴风音影","permalink":"//blog.kongfanjian.com/tags/暴风音影/"},{"name":"政治正确","slug":"政治正确","permalink":"//blog.kongfanjian.com/tags/政治正确/"}]},{"title":"300行 Golang 实现区块链","date":"2017-04-20T07:09:41.000Z","path":"2017/04/20/300-line-blockchain-in-go/","text":"0x1 开篇&emsp;&emsp;区块链，时下最火的技术。一篇《A blockchain in 200 lines of code》更是在技术圈里刷屏。在读过 Lauri Hartikka 写的这篇文章和代码后，我愈发对区块链兴趣浓厚。&emsp;&emsp;纸上得来终觉浅，要深入了解一门技术，终究是需要自己造一次轮子。于是，我着手用 Go 语言仿造着实现了一个 naivechain。 0x2 区块数据结构&emsp;&emsp;和 Lauri Hartikka 一样，数据结构上我们一切从简，只使用 Index，PreviousHash，Timestamp，Data，Hash 这几个必要的字段。1234567type Block struct &#123; Index int64 `json:\"index\"` // 区块索引 PreviousHash string `json:\"previousHash\"` // 前块哈希 Timestamp int64 `json:\"timestamp\"` // 时间戳 Data string `json:\"data\"` // 区块数据 Hash string `json:\"hash\"` // 区块哈希&#125; 0x3 区块哈希&emsp;&emsp;区块哈希用于验证区块数据的完整性，使用 SHA-256 算法生成Index， PreviousHash，Timestamp， Data 拼接字符串的摘要。123456func calculateHashForBlock(b *Block) string &#123; return fmt.Sprintf(\"%x\", sha256.Sum256( []byte(fmt.Sprintf(\"%d%s%d%s\", b.Index, b.PreviousHash, b.Timestamp, b.Data))))&#125; 0x4 创建新区块&emsp;&emsp;为了生成新区块，我们需要知道前区块和新区块的必要数据（Index，Hash，Timestamp， Data）;区块数据由终端用户提供。1234567891011func generateNextBlock(data string) (nb *Block) &#123; var previousBlock = getLatestBlock() nb = &amp;Block&#123; Data: data, PreviousHash: previousBlock.Hash, Index: previousBlock.Index + 1, Timestamp: time.Now().Unix(), &#125; nb.Hash = calculateHashForBlock(nb) return&#125; 0x5 创世块&emsp;&emsp;区块链的第一个区块被称之为创世块，被硬编码在程序内。1234567var genesisBlock = &amp;Block&#123; Index: 0, PreviousHash: \"0\", Timestamp: 1465154705, Data: \"my genesis block!!\", Hash: \"816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7\",&#125; 0x6 区块存储&emsp;&emsp;这里使用 Go 语言的 Slice 存储区块。区块链是有序 List，为了保证有序性，需要对内存中保存区块的数组进行排序。定义按 Index 排序的结构体 ByIndex，并实现 sort.Interface：12345type ByIndex []*Blockfunc (b ByIndex) Len() int &#123; return len(b) &#125;func (b ByIndex) Swap(i, j int) &#123; b[i], b[j] = b[j], b[i] &#125;func (b ByIndex) Less(i, j int) bool &#123; return b[i].Index &lt; b[j].Index &#125; 0x7 区块完整性验证12345678func isValidNewBlock(nb, pb *Block) (ok bool) &#123; if nb.Hash == calculateHashForBlock(nb) &amp;&amp; pb.Index+1 == nb.Index &amp;&amp; pb.Hash == nb.PreviousHash &#123; ok = true &#125; return&#125; 0x8 节点通讯&emsp;&emsp;每个节点在启动时监听一个端口（由 -p2p 参数指定），使用 websocket 协议和其它节点通讯。 0x9 节点控制&emsp;&emsp;没个节点在启动时监听一个端口（由 -api 参数指定），接收 HTTP 协议的 JSON 控制命令。使用示例： 查看区块 1curl http://localhost:3001/blocks 创建区块 1curl -H \"Content-type:application/json\" --data '&#123;\"data\" : \"Some data to the first block\"&#125;' http://localhost:3001/mine_block 添加节点 1curl -H \"Content-type:application/json\" --data '&#123;\"peer\" : \"ws://localhost:6002\"&#125;' http://localhost:3001/add_peer 查看节点 1curl http://localhost:3001/peers 0xA 结语&emsp;&emsp;这是一个最简单的区块链实现，用于学习区块链的工作原理，因为没用实现工作量证明这一类的挖矿算法，不适宜在公共网络使用。更多的细节请访问 Github: https://github.com/kofj/naivechain。&emsp;&emsp;最后，欢迎在 Github 点击 star，或者 打赏比特币 支持我：&emsp;&emsp;又或者加入我主持的数字货币投资俱乐部：","content":"<h3 id=\"0x1-开篇\"><a href=\"#0x1-开篇\" class=\"headerlink\" title=\"0x1 开篇\"></a>0x1 开篇</h3><p>&emsp;&emsp;区块链，时下最火的技术。一篇<a href=\"https://medium.com/@lhartikk/a-blockchain-in-200-lines-of-code-963cc1cc0e54\" target=\"_blank\" rel=\"external\">《A blockchain in 200 lines of code》</a>更是在技术圈里刷屏。在读过 Lauri Hartikka 写的这篇文章和代码后，我愈发对区块链兴趣浓厚。<br>&emsp;&emsp;纸上得来终觉浅，要深入了解一门技术，终究是需要自己造一次轮子。于是，我着手用 Go 语言仿造着实现了一个 <strong><a href=\"https://github.com/kofj/naivechain\" target=\"_blank\" rel=\"external\">naivechain</a></strong>。</p>\n<a id=\"more\"></a>\n<h3 id=\"0x2-区块数据结构\"><a href=\"#0x2-区块数据结构\" class=\"headerlink\" title=\"0x2 区块数据结构\"></a>0x2 区块数据结构</h3><p>&emsp;&emsp;和 Lauri Hartikka 一样，数据结构上我们一切从简，只使用 <code>Index</code>，<code>PreviousHash</code>，<code>Timestamp</code>，<code>Data</code>，<code>Hash</code> 这几个必要的字段。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> Block <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">\tIndex        <span class=\"keyword\">int64</span>  <span class=\"string\">`json:\"index\"`</span>        <span class=\"comment\">// 区块索引</span></div><div class=\"line\">\tPreviousHash <span class=\"keyword\">string</span> <span class=\"string\">`json:\"previousHash\"`</span> <span class=\"comment\">// 前块哈希</span></div><div class=\"line\">\tTimestamp    <span class=\"keyword\">int64</span>  <span class=\"string\">`json:\"timestamp\"`</span>    <span class=\"comment\">// 时间戳</span></div><div class=\"line\">\tData         <span class=\"keyword\">string</span> <span class=\"string\">`json:\"data\"`</span>         <span class=\"comment\">// 区块数据</span></div><div class=\"line\">\tHash         <span class=\"keyword\">string</span> <span class=\"string\">`json:\"hash\"`</span>         <span class=\"comment\">// 区块哈希</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"0x3-区块哈希\"><a href=\"#0x3-区块哈希\" class=\"headerlink\" title=\"0x3 区块哈希\"></a>0x3 区块哈希</h3><p>&emsp;&emsp;<code>区块哈希</code>用于验证<code>区块数据</code>的完整性，使用 <strong>SHA-256</strong> 算法生成<code>Index</code>， <code>PreviousHash</code>，<code>Timestamp</code>， <code>Data</code> 拼接字符串的摘要。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">calculateHashForBlock</span><span class=\"params\">(b *Block)</span> <span class=\"title\">string</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">\"%x\"</span>,</div><div class=\"line\">\t\tsha256.Sum256(</div><div class=\"line\">\t\t\t[]<span class=\"keyword\">byte</span>(fmt.Sprintf(<span class=\"string\">\"%d%s%d%s\"</span>,</div><div class=\"line\">\t\t\t\tb.Index, b.PreviousHash, b.Timestamp, b.Data))))</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"0x4-创建新区块\"><a href=\"#0x4-创建新区块\" class=\"headerlink\" title=\"0x4 创建新区块\"></a>0x4 创建新区块</h3><p>&emsp;&emsp;为了生成新区块，我们需要知道<code>前区块</code>和新区块的必要数据（<code>Index</code>，<code>Hash</code>，<code>Timestamp</code>， <code>Data</code>）;<code>区块数据</code>由终端用户提供。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateNextBlock</span><span class=\"params\">(data <span class=\"keyword\">string</span>)</span> <span class=\"params\">(nb *Block)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> previousBlock = getLatestBlock()</div><div class=\"line\">\tnb = &amp;Block&#123;</div><div class=\"line\">\t\tData:         data,</div><div class=\"line\">\t\tPreviousHash: previousBlock.Hash,</div><div class=\"line\">\t\tIndex:        previousBlock.Index + <span class=\"number\">1</span>,</div><div class=\"line\">\t\tTimestamp:    time.Now().Unix(),</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tnb.Hash = calculateHashForBlock(nb)</div><div class=\"line\">\t<span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"0x5-创世块\"><a href=\"#0x5-创世块\" class=\"headerlink\" title=\"0x5 创世块\"></a>0x5 创世块</h3><p>&emsp;&emsp;区块链的第一个区块被称之为<code>创世块</code>，被硬编码在程序内。<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> genesisBlock = &amp;Block&#123;</div><div class=\"line\">\tIndex:        <span class=\"number\">0</span>,</div><div class=\"line\">\tPreviousHash: <span class=\"string\">\"0\"</span>,</div><div class=\"line\">\tTimestamp:    <span class=\"number\">1465154705</span>,</div><div class=\"line\">\tData:         <span class=\"string\">\"my genesis block!!\"</span>,</div><div class=\"line\">\tHash: <span class=\"string\">\"816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7\"</span>,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"0x6-区块存储\"><a href=\"#0x6-区块存储\" class=\"headerlink\" title=\"0x6 区块存储\"></a>0x6 区块存储</h3><p>&emsp;&emsp;这里使用 Go 语言的 Slice 存储区块。区块链是有序 List，为了保证有序性，需要对内存中保存区块的数组进行排序。定义按 <code>Index</code> 排序的结构体 <code>ByIndex</code>，并实现 <code>sort.Interface</code>：<br><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">type</span> ByIndex []*Block</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b ByIndex)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span>           &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(b) &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b ByIndex)</span> <span class=\"title\">Swap</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span></span>      &#123; b[i], b[j] = b[j], b[i] &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(b ByIndex)</span> <span class=\"title\">Less</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123; <span class=\"keyword\">return</span> b[i].Index &lt; b[j].Index &#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"0x7-区块完整性验证\"><a href=\"#0x7-区块完整性验证\" class=\"headerlink\" title=\"0x7 区块完整性验证\"></a>0x7 区块完整性验证</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidNewBlock</span><span class=\"params\">(nb, pb *Block)</span> <span class=\"params\">(ok <span class=\"keyword\">bool</span>)</span></span> &#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> nb.Hash == calculateHashForBlock(nb) &amp;&amp;</div><div class=\"line\">\t\tpb.Index+<span class=\"number\">1</span> == nb.Index &amp;&amp;</div><div class=\"line\">\t\tpb.Hash == nb.PreviousHash &#123;</div><div class=\"line\">\t\tok = <span class=\"literal\">true</span></div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"0x8-节点通讯\"><a href=\"#0x8-节点通讯\" class=\"headerlink\" title=\"0x8 节点通讯\"></a>0x8 节点通讯</h3><p>&emsp;&emsp;每个节点在启动时监听一个端口（由 <code>-p2p</code> 参数指定），使用 <strong>websocket</strong> 协议和其它节点通讯。</p>\n<h3 id=\"0x9-节点控制\"><a href=\"#0x9-节点控制\" class=\"headerlink\" title=\"0x9 节点控制\"></a>0x9 节点控制</h3><p>&emsp;&emsp;没个节点在启动时监听一个端口（由 <code>-api</code> 参数指定），接收 <strong>HTTP</strong> 协议的 <strong>JSON</strong> 控制命令。使用示例：</p>\n<ul>\n<li><p>查看区块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl http://localhost:3001/blocks</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建区块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -H <span class=\"string\">\"Content-type:application/json\"</span> --data <span class=\"string\">'&#123;\"data\" : \"Some data to the first block\"&#125;'</span> http://localhost:3001/mine_block</div></pre></td></tr></table></figure>\n</li>\n<li><p>添加节点</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -H <span class=\"string\">\"Content-type:application/json\"</span> --data <span class=\"string\">'&#123;\"peer\" : \"ws://localhost:6002\"&#125;'</span> http://localhost:3001/add_peer</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看节点</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl http://localhost:3001/peers</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"0xA-结语\"><a href=\"#0xA-结语\" class=\"headerlink\" title=\"0xA 结语\"></a>0xA 结语</h3><p>&emsp;&emsp;这是一个最简单的区块链实现，用于学习区块链的工作原理，因为没用实现工作量证明这一类的挖矿算法，不适宜在公共网络使用。更多的细节请访问 Github: <a href=\"https://github.com/kofj/naivechain\" target=\"_blank\" rel=\"external\">https://github.com/kofj/naivechain</a>。<br>&emsp;&emsp;最后，欢迎在 <strong><a href=\"https://github.com/kofj/naivechain\" target=\"_blank\" rel=\"external\">Github 点击 star</a></strong>，或者 <strong>打赏比特币</strong> 支持我：<br><img src=\"http://ww1.sinaimg.cn/large/6816152bly1fet6le7z47j20go0go0st\" alt=\"打赏1mBTC\"><br>&emsp;&emsp;又或者加入我主持的<strong>数字货币投资俱乐部</strong>：<br><img src=\"http://ww1.sinaimg.cn/large/6816152bly1fet6hi47koj20qc10p0ua\" alt=\"数字货币投资俱乐部\"></p>\n","updated":"2017-04-21T02:27:25.000Z","excerpt":"0x1 开篇&emsp;&emsp;区块链，时下最火的技术。一篇《A blockchain in 200 lines of code》更是在技术圈里刷屏。在读过 Lauri Hartikka 写的这篇文章和代码后，我愈发对区块链兴趣浓厚。&emsp;&emsp;纸上得来终觉浅，要深入了解一门技术，终究是需要自己造一次轮子。于是，我着手用 Go 语言仿造着实现了一个 naivechain。","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"golang","slug":"golang","permalink":"//blog.kongfanjian.com/tags/golang/"},{"name":"blockchain","slug":"blockchain","permalink":"//blog.kongfanjian.com/tags/blockchain/"}]},{"title":"JS 遍历 NodeList 对象","date":"2016-12-13T20:06:52.000Z","path":"2016/12/14/foreach-NodeList-of-JavaScript/","text":"阅读提示 - 文章领域：计算机专业 - 阅读时长：大约3分钟 0x1 问题描述&emsp;&emsp;我博客使用的 Yilia 主题在移动设备上有这样一个问题：标签无法正常显示。使用 Chrome 浏览器进行远程调试，捕捉到了下列错误信息：123Uncaught TypeError: $tags.forEach is not a functioninit @ fix.js?9699:25window.onload @ main.js?8359:24 &emsp;&emsp;$tags 是一个 NodeList 对象，在 Macbook Chrome 上 forEach 方法对其进行遍历没有问题，但是在 Android 手机的原生浏览器和 Chrome浏览器都会出现错误。 0x2 溯源&emsp;&emsp;JavaScript 的继承机制是基于原型的。例如，一个数组元素 arr 上之所以有一些数组方法（比如 forEach）,是因为它的原型链上有这些方法：&emsp;&emsp;arr → Arrary.prototype → Object.prototype → null&emsp;&emsp;NodeList 元素 tags 的原型链如下：&emsp;&emsp;tags → NodeList.prototype → Object.prototype → null&emsp;&emsp;如果 NodeList 的原型上没有 forEach 方法，调用该方法必然会报错。查阅文档可知，DOM4 中的 NodeList 接口只实现了 item 方法。&emsp;&emsp;不过，只有一些旧的浏览器中 NodeList 对象还没有实现 forEach、values 这些方法。所以，尽管 NodeList 不是 Array，它也是能够使用 forEach 方法遍历元素的。 我在手机上使用的 Chrome 浏览器比较老旧，版本是 47.0.2526.83。使用 Object.getPrototypeOf 查看 NodeList 原型，发现确实是只实现了 item 方法。而在 Macbook 上安装的则是最新版的 Chrome 浏览器。&emsp;&emsp;归根结底，问题是出在了对老版本浏览器的兼容上。 0x3 解决方案&emsp;&emsp;我们可以简单的通过 prototypes 扩展 NodeList 的方法来兼容老浏览器。不过这样做可能会遇到一些问题，具体可以查阅参考文献第三条。1NodeList.prototype.forEach = Array.prototype.forEach &emsp;&emsp;除了通过 prototypes 扩展 DOM 方法外，我们还可以直接使用 for 循环或者是自定义一个 forEach 的函数来遍历 NodeList。 参考文献 NodeList, https://developer.mozilla.org/en-US/docs/Web/API/NodeList DOM4, https://www.w3.org/TR/dom/#interface-nodelist Ditch the [].forEach.call(NodeList) hack, https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/","content":"<p><strong>阅读提示</strong></p>\n<pre><code>- 文章领域：计算机专业\n- 阅读时长：大约3分钟\n</code></pre><h2 id=\"0x1-问题描述\"><a href=\"#0x1-问题描述\" class=\"headerlink\" title=\"0x1 问题描述\"></a>0x1 问题描述</h2><p>&emsp;&emsp;我博客使用的 <code>Yilia</code> 主题在移动设备上有这样一个问题：标签无法正常显示。使用 Chrome 浏览器进行远程调试，捕捉到了下列错误信息：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Uncaught <span class=\"built_in\">TypeError</span>: $tags.forEach is not a <span class=\"function\"><span class=\"keyword\">function</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">init</span> @ <span class=\"title\">fix</span>.<span class=\"title\">js</span>?9699:25</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">window</span>.<span class=\"title\">onload</span> @ <span class=\"title\">main</span>.<span class=\"title\">js</span>?8359:24</span></div></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>$tags</code> 是一个 <code>NodeList</code> 对象，在 Macbook <strong>Chrome</strong> 上 <code>forEach</code> 方法对其进行遍历没有问题，但是在 Android 手机的原生浏览器和 Chrome浏览器都会出现错误。<br><a id=\"more\"></a></p>\n<h2 id=\"0x2-溯源\"><a href=\"#0x2-溯源\" class=\"headerlink\" title=\"0x2 溯源\"></a>0x2 溯源</h2><p>&emsp;&emsp;JavaScript 的继承机制是基于原型的。例如，一个数组元素 <code>arr</code> 上之所以有一些数组方法（比如 <code>forEach</code>）,是因为它的原型链上有这些方法：<br>&emsp;&emsp;arr → Arrary.prototype → Object.prototype → null<br>&emsp;&emsp;<code>NodeList</code> 元素 tags 的原型链如下：<br>&emsp;&emsp;tags → NodeList.prototype → Object.prototype → null<br>&emsp;&emsp;如果 NodeList 的原型上没有 <code>forEach</code> 方法，调用该方法必然会报错。查阅文档可知，<a href=\"https://www.w3.org/TR/dom/#interface-nodelist\" target=\"_blank\" rel=\"external\">DOM4</a> 中的 <code>NodeList</code> 接口只实现了 <code>item</code> 方法。<br>&emsp;&emsp;不过，只有一些旧的浏览器中 <code>NodeList</code> 对象还没有实现 <code>forEach</code>、<code>values</code> 这些方法。所以，尽管 <code>NodeList</code> 不是 <code>Array</code>，它也是能够使用 <code>forEach</code> 方法遍历元素的。<br>  我在手机上使用的 Chrome 浏览器比较老旧，版本是 <code>47.0.2526.83</code>。使用 <code>Object.getPrototypeOf</code> 查看 <code>NodeList</code> 原型，发现确实是只实现了 <code>item</code> 方法。而在 Macbook 上安装的则是最新版的 Chrome 浏览器。<br>&emsp;&emsp;归根结底，问题是出在了对老版本浏览器的兼容上。</p>\n<h2 id=\"0x3-解决方案\"><a href=\"#0x3-解决方案\" class=\"headerlink\" title=\"0x3 解决方案\"></a>0x3 解决方案</h2><p>&emsp;&emsp;我们可以简单的通过 <code>prototypes</code> 扩展 NodeList 的方法来兼容老浏览器。不过这样做可能会遇到一些问题，具体可以查阅参考文献第三条。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">NodeList.prototype.forEach = <span class=\"built_in\">Array</span>.prototype.forEach</div></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;除了通过 <code>prototypes</code> 扩展 <code>DOM</code> 方法外，我们还可以直接使用 <code>for</code> 循环或者是自定义一个 forEach 的函数来遍历 NodeList。</p>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/NodeList\" target=\"_blank\" rel=\"external\">NodeList</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/NodeList\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/API/NodeList</a></li>\n<li><a href=\"https://www.w3.org/TR/dom/#interface-nodelist\" target=\"_blank\" rel=\"external\">DOM4</a>, <a href=\"https://www.w3.org/TR/dom/#interface-nodelist\" target=\"_blank\" rel=\"external\">https://www.w3.org/TR/dom/#interface-nodelist</a></li>\n<li><a href=\"https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/\" target=\"_blank\" rel=\"external\">Ditch the [].forEach.call(NodeList) hack</a>, <a href=\"https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/\" target=\"_blank\" rel=\"external\">https://toddmotto.com/ditch-the-array-foreach-call-nodelist-hack/</a></li>\n</ol>\n","updated":"2017-08-12T03:56:52.000Z","excerpt":"阅读提示 - 文章领域：计算机专业 - 阅读时长：大约3分钟 0x1 问题描述&emsp;&emsp;我博客使用的 Yilia 主题在移动设备上有这样一个问题：标签无法正常显示。使用 Chrome 浏览器进行远程调试，捕捉到了下列错误信息：123Uncaught TypeError: $tags.forEach is not a functioninit @ fix.js?9699:25window.onload @ main.js?8359:24 &emsp;&emsp;$tags 是一个 NodeList 对象，在 Macbook Chrome 上 forEach 方法对其进行遍历没有问题，但是在 Android 手机的原生浏览器和 Chrome浏览器都会出现错误。","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"},{"name":"前端","slug":"术业/前端","permalink":"//blog.kongfanjian.com/categories/术业/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"//blog.kongfanjian.com/tags/JavaScript/"}]},{"title":"始与终","date":"2015-04-03T05:05:16.000Z","path":"2015/04/03/始与终/","text":"&emsp;&emsp;感激夹杂着怨气,痛快参合着不舍,我踏出了身后这座小楼,离开了工作了近一年的公司.站在喧嚣的街边,抬头仰望着北京城这难得一见的蔚蓝天空,深深吸了一口雨后不再那么混浊的空气.是是非非,恩恩怨怨,看开了也不过如天边的白云,转眼便成了过眼云烟.&emsp;&emsp;14年七月的北京城是否炎热我已经没有了多少印象,对我来说却是如坠冰窖.常言道,天有不测风云.乔迁之喜的氛围还尚未散去,偌大的一个集团公司就陷入了泥沼之中.甲方拖欠工程款,供应商追讨欠款,资金出现了断链,大老板不得不拿房屋抵押借贷勉力维持着公司的运营.然而这不过是杯水车薪罢了.&emsp;&emsp;我在岗位上尽职尽力,直属领导也是待我至深.勉力维持了两个月后,公司的职员也是已经走的七七八八了.经理不忍我再留在这里,眼看着公司倒下.和大老板协商后,公司方面主动和我解除了劳动合约.带着一笔违约金和眷恋,离开了这个工作尚未满一年的公司.&emsp;&emsp;心里带着几分沉闷,恰巧此间二姑姑大寿,便决定回老家给姑姑祝寿,顺道游玩一番,排解心情.&emsp;&emsp;从管理岗位下来,成了无业游民,被这落差打击的无法自拔.本是希望出去走走玩玩,能放松心情.但天不遂人愿.从山东回到北京,心情并没有多大好转.有言道,心态决定命运.越是心情烦躁低沉越是事事不顺,一个月了,依旧没有找到工作.此时,峰回路转.在面试安卓联航的时候,老板一句话让我重新燃起了自信:你下午能开始工作嘛?一股被人需要的感觉从心底油然而生.这也便是我对领导的感激.&emsp;&emsp;磨刀不误砍柴工.对于软件工程师来说,一台性能优异的计算机就是他手中的倚天屠龙.若是没记错,公司给配置的一台4G内存,i3 CPU,5400rpm机械硬盘的PC机.内存和处理器不高,还能凑合使用.可恨的是,这硬盘的IO实在是渣到了底,只是使用Sublime Text 2编辑个源码文件都会时不时的卡顿一下.这性能,还不如大学期间买的联想的G470的性能.在飞报App的项目后期,不得不一纸报告请求领导升级电脑配置.这事儿却如同石城大海,没了音信.&emsp;&emsp;怨恨自此心生.&emsp;&emsp;庆功宴放鸽子,承诺的项目奖金选择性的遗忘,联通项目加班不断致使身体积劳成病,各种是是非非,对公司积怨根深.在我看来,这些都是沟通不畅造成的.&emsp;&emsp;15年,在完成了手里的最后一个项目后,我选择了离开.压抑久了,离开那一瞬间不无痛快,痛快却参合着不舍.这即是终结,也是一个全新的开始.&emsp;&emsp;开始是容易的,正如恋人间一般,一颦一笑或是不经意间的一句话,便开始了一段缘分.天下没有不散的宴席,善终却是颇为不易.倘若领导和员工间多理解一下对方,上下级间多沟通,想必工作中便不会有这么多的是是非非.一批批的员工也不会带着愤恨不满离开.反思,反思我自己,也替公司反思.这便是和此家公司最后的诀别,自此,无瓜葛.– END –","content":"<p>&emsp;&emsp;感激夹杂着怨气,痛快参合着不舍,我踏出了身后这座小楼,离开了工作了近一年的公司.站在喧嚣的街边,抬头仰望着北京城这难得一见的蔚蓝天空,深深吸了一口雨后不再那么混浊的空气.是是非非,恩恩怨怨,看开了也不过如天边的白云,转眼便成了过眼云烟.<a id=\"more\"></a><br>&emsp;&emsp;14年七月的北京城是否炎热我已经没有了多少印象,对我来说却是如坠冰窖.常言道,天有不测风云.乔迁之喜的氛围还尚未散去,偌大的一个集团公司就陷入了泥沼之中.甲方拖欠工程款,供应商追讨欠款,资金出现了断链,大老板不得不拿房屋抵押借贷勉力维持着公司的运营.然而这不过是杯水车薪罢了.<br>&emsp;&emsp;我在岗位上尽职尽力,直属领导也是待我至深.勉力维持了两个月后,公司的职员也是已经走的七七八八了.经理不忍我再留在这里,眼看着公司倒下.和大老板协商后,公司方面主动和我解除了劳动合约.带着一笔违约金和眷恋,离开了这个工作尚未满一年的公司.<br>&emsp;&emsp;心里带着几分沉闷,恰巧此间二姑姑大寿,便决定回老家给姑姑祝寿,顺道游玩一番,排解心情.<br>&emsp;&emsp;从管理岗位下来,成了无业游民,被这落差打击的无法自拔.本是希望出去走走玩玩,能放松心情.但天不遂人愿.从山东回到北京,心情并没有多大好转.有言道,心态决定命运.越是心情烦躁低沉越是事事不顺,一个月了,依旧没有找到工作.此时,峰回路转.在面试安卓联航的时候,老板一句话让我重新燃起了自信:你下午能开始工作嘛?一股被人需要的感觉从心底油然而生.这也便是我对领导的感激.<br>&emsp;&emsp;磨刀不误砍柴工.对于软件工程师来说,一台性能优异的计算机就是他手中的倚天屠龙.若是没记错,公司给配置的一台4G内存,i3 CPU,5400rpm机械硬盘的PC机.内存和处理器不高,还能凑合使用.可恨的是,这硬盘的IO实在是渣到了底,只是使用Sublime Text 2编辑个源码文件都会时不时的卡顿一下.这性能,还不如大学期间买的联想的G470的性能.在飞报App的项目后期,不得不一纸报告请求领导升级电脑配置.这事儿却如同石城大海,没了音信.<br>&emsp;&emsp;怨恨自此心生.<br>&emsp;&emsp;庆功宴放鸽子,承诺的项目奖金选择性的遗忘,联通项目加班不断致使身体积劳成病,各种是是非非,对公司积怨根深.在我看来,这些都是沟通不畅造成的.<br>&emsp;&emsp;15年,在完成了手里的最后一个项目后,我选择了离开.压抑久了,离开那一瞬间不无痛快,痛快却参合着不舍.这即是终结,也是一个全新的开始.<br>&emsp;&emsp;开始是容易的,正如恋人间一般,一颦一笑或是不经意间的一句话,便开始了一段缘分.天下没有不散的宴席,善终却是颇为不易.倘若领导和员工间<strong>多理解</strong>一下对方,上下级间<strong>多沟通</strong>,想必工作中便不会有这么多的是是非非.一批批的员工也不会带着愤恨不满离开.反思,反思我自己,也替公司反思.这便是和此家公司最后的诀别,自此,无瓜葛.<br>– END –</p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"&emsp;&emsp;感激夹杂着怨气,痛快参合着不舍,我踏出了身后这座小楼,离开了工作了近一年的公司.站在喧嚣的街边,抬头仰望着北京城这难得一见的蔚蓝天空,深深吸了一口雨后不再那么混浊的空气.是是非非,恩恩怨怨,看开了也不过如天边的白云,转眼便成了过眼云烟.","categories":[{"name":"浮生","slug":"浮生","permalink":"//blog.kongfanjian.com/categories/浮生/"}],"tags":[{"name":"职业","slug":"职业","permalink":"//blog.kongfanjian.com/tags/职业/"},{"name":"反思","slug":"反思","permalink":"//blog.kongfanjian.com/tags/反思/"}]},{"title":"使用git archive增量包","date":"2015-03-16T08:22:26.000Z","path":"2015/03/16/使用git-archive构建增量包/","text":"&emsp;&emsp;在没有项目版本仓库的使用权限的情况时,或者客户的生产环境没有自动化部署工具时,我们在修改了程序后需要生成一个增量包给同事/客户.逐个的检出文件到压缩包里面是个笨办法,若你马虎一下,便可能会落下个文件.保持代码的目录结构也是个麻烦事儿.使用git archive生成增量包则要方便很多.当然,前提是你本地有用git管理代码版本.&emsp;&emsp;如果你的代码没有使用git做版本管理,修改代码之前,可以代码目录创建一个本地仓库.1234#cd SourcePath #进入项目目录git init #在当前目录创建一个新的空的本地仓库git add . #把当前目录下的所有文件全部添加到暂存区git commit -m 'Project init.' #提交创建 &emsp;&emsp;此后,就能方便的使用git archive生成增量包了.使用示例如下,dbce55b是代码修改前的版本号,59b2e92是代码修改完成后的版本号:1git archive -o update.zip HEAD $(git diff dbce55b...59b2e92 --name-only)","content":"<p>&emsp;&emsp;在没有项目版本仓库的使用权限的情况时,或者客户的生产环境没有自动化部署工具时,我们在修改了程序后需要生成一个增量包给同事/客户.逐个的检出文件到压缩包里面是个笨办法,若你马虎一下,便可能会落下个文件.保持代码的目录结构也是个麻烦事儿.使用<code>git archive</code>生成增量包则要方便很多.当然,前提是你本地有用git管理代码版本.<br><a id=\"more\"></a><br>&emsp;&emsp;如果你的代码没有使用git做版本管理,修改代码之前,可以代码目录创建一个本地仓库.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#cd SourcePath #进入项目目录</span></div><div class=\"line\">git init <span class=\"comment\">#在当前目录创建一个新的空的本地仓库</span></div><div class=\"line\">git add . <span class=\"comment\">#把当前目录下的所有文件全部添加到暂存区</span></div><div class=\"line\">git commit -m <span class=\"string\">'Project init.'</span> <span class=\"comment\">#提交创建</span></div></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;此后,就能方便的使用<code>git archive</code>生成增量包了.使用示例如下,<code>dbce55b</code>是代码修改前的版本号,<code>59b2e92</code>是代码修改完成后的版本号:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git archive -o update.zip HEAD $(git diff dbce55b...59b2e92 --name-only)</div></pre></td></tr></table></figure></p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"&emsp;&emsp;在没有项目版本仓库的使用权限的情况时,或者客户的生产环境没有自动化部署工具时,我们在修改了程序后需要生成一个增量包给同事/客户.逐个的检出文件到压缩包里面是个笨办法,若你马虎一下,便可能会落下个文件.保持代码的目录结构也是个麻烦事儿.使用git archive生成增量包则要方便很多.当然,前提是你本地有用git管理代码版本.","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"git","slug":"git","permalink":"//blog.kongfanjian.com/tags/git/"},{"name":"归档","slug":"归档","permalink":"//blog.kongfanjian.com/tags/归档/"},{"name":"增量","slug":"增量","permalink":"//blog.kongfanjian.com/tags/增量/"}]},{"title":"永久删除git仓库中的文件与历史记录","date":"2015-03-02T07:14:15.000Z","path":"2015/03/02/永久删除git仓库中的文件与历史记录/","text":"&emsp;&emsp;之前托管在git@osc的私有项目神马磁力搜索想要开源,作为个人技能展示作品.这就遇到了一个问题,脱离敏感数据.通过git rm file肯定是不能够满足这一需求的,git历史记录中还是能够查看被删除的内容的,导致敏感数据的泄露.那么,就必须要彻底删除git的历史记录了. 0x1 从仓库总清除文件&emsp;&emsp;打开bash,进入项目目录,执行以下命令:1git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch path-of-remove-file' --prune-empty --tag-name-filter cat -- --all &emsp;&emsp;path-of-remove-file是你要删除的文件的相对目录(相对于git repo的根目录),可以使用通配符*匹配文件进行批量删除.当看到类似于下面的提示信息说明删除成功了:12Rewrite 59b2e9e1bdc898daa52085648d3a8def767560dc (429/429)# Ref 'refs/heads/master' was rewritten &emsp;&emsp;如果执行上述命令后出现的提示信息中有unchanged字样,说明repo中没有找到path-of-remove-file,请仔细检查路径和文件名是否正确. 0x2 推送修改结果1git push origin master --force #强制覆盖 0x3 回收磁盘空间&emsp;&emsp;经过上述操作后,我们已经删除了文件,但是本地仓库中任然保留着这些objects.我们需要使用GC命令进行垃圾回收,彻底清除这些文件,回收磁盘空间.#后面为执行结果,我们可以看见.git目录大小明显缩小了.1234567891011121314151617181920rm -rf .git/refs/original/du -sh .git# 11M .gitgit reflog expire --expire=now --allgit gc --prune=now#Counting objects: 3370, done.#Delta compression using up to 4 threads.#Compressing objects: 100% (2047/2047), done.#Writing objects: 100% (3370/3370), done.#Total 3370 (delta 1333), reused 2891 (delta 1108)du -sh .git/*#7.5M .gitgit gc --aggressive --prune=now#Counting objects: 3370, done.#Delta compression using up to 4 threads.#Compressing objects: 100% (3155/3155), done.#Writing objects: 100% (3370/3370), done.#Total 3370 (delta 1419), reused 1944 (delta 0)du -sh .git#7.3M .git","content":"<p>&emsp;&emsp;之前托管在git@osc的私有项目<code>神马磁力搜索</code>想要开源,作为个人技能展示作品.这就遇到了一个问题,脱离敏感数据.通过<code>git rm file</code>肯定是不能够满足这一需求的,git历史记录中还是能够查看被删除的内容的,导致敏感数据的泄露.那么,就必须要彻底删除git的历史记录了.<br><a id=\"more\"></a></p>\n<h2 id=\"0x1-从仓库总清除文件\"><a href=\"#0x1-从仓库总清除文件\" class=\"headerlink\" title=\"0x1 从仓库总清除文件\"></a>0x1 从仓库总清除文件</h2><p>&emsp;&emsp;打开bash,进入项目目录,执行以下命令:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch path-of-remove-file' --prune-empty --tag-name-filter cat -- --all</div></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;<code>path-of-remove-file</code>是你要删除的文件的相对目录(相对于git repo的根目录),可以使用通配符<code>*</code>匹配文件进行批量删除.当看到类似于下面的提示信息说明删除成功了:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Rewrite 59b2e9e1bdc898daa52085648d3a8def767560dc (429/429)</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Ref <span class=\"string\">'refs/heads/master'</span> was rewritten</span></div></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;如果执行上述命令后出现的提示信息中有<code>unchanged</code>字样,说明repo中没有找到<code>path-of-remove-file</code>,请仔细检查路径和文件名是否正确.</p>\n<h2 id=\"0x2-推送修改结果\"><a href=\"#0x2-推送修改结果\" class=\"headerlink\" title=\"0x2 推送修改结果\"></a>0x2 推送修改结果</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin master --force #强制覆盖</div></pre></td></tr></table></figure>\n<h2 id=\"0x3-回收磁盘空间\"><a href=\"#0x3-回收磁盘空间\" class=\"headerlink\" title=\"0x3 回收磁盘空间\"></a>0x3 回收磁盘空间</h2><p>&emsp;&emsp;经过上述操作后,我们已经删除了文件,但是本地仓库中任然保留着这些objects.我们需要使用GC命令进行垃圾回收,彻底清除这些文件,回收磁盘空间.<code>#</code>后面为执行结果,我们可以看见.git目录大小明显缩小了.<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf .git/refs/original/</div><div class=\"line\">du -sh .git</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 11M\t.git</span></div><div class=\"line\">git reflog expire --expire=now --all</div><div class=\"line\">git gc --prune=now</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Counting objects: 3370, <span class=\"keyword\">done</span>.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Delta compression using up to 4 threads.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Compressing objects: 100% (2047/2047), <span class=\"keyword\">done</span>.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Writing objects: 100% (3370/3370), <span class=\"keyword\">done</span>.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Total 3370 (delta 1333), reused 2891 (delta 1108)</span></div><div class=\"line\">du -sh .git/*</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">7.5M\t.git</span></div><div class=\"line\">git gc --aggressive --prune=now</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Counting objects: 3370, <span class=\"keyword\">done</span>.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Delta compression using up to 4 threads.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Compressing objects: 100% (3155/3155), <span class=\"keyword\">done</span>.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Writing objects: 100% (3370/3370), <span class=\"keyword\">done</span>.</span></div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">Total 3370 (delta 1419), reused 1944 (delta 0)</span></div><div class=\"line\">du -sh .git</div><div class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">7.3M\t.git</span></div></pre></td></tr></table></figure></p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"&emsp;&emsp;之前托管在git@osc的私有项目神马磁力搜索想要开源,作为个人技能展示作品.这就遇到了一个问题,脱离敏感数据.通过git rm file肯定是不能够满足这一需求的,git历史记录中还是能够查看被删除的内容的,导致敏感数据的泄露.那么,就必须要彻底删除git的历史记录了.","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"git","slug":"git","permalink":"//blog.kongfanjian.com/tags/git/"}]},{"title":"美味西蜀年夜饭[图多杀猫]","date":"2015-02-19T14:57:07.000Z","path":"2015/02/19/美味西蜀年夜饭-图多杀猫/","text":"&emsp;&emsp;四川素有天府之国的美称,川菜更是在中华八大菜系中颇具影响力.天府之人,在骨子中都透露着对美食的追求,寻常百姓的家常饭亦是美味连连.华夏儿女不论富贵贫贱,年间总会摆上桌味美的年饭,和亲朋相聚.西蜀雨城一席年饭,欲与众人分享.&emsp;&emsp;其中一桌. &emsp;&emsp;泡脚凤爪,个大肉多(传说中的荤泡菜). &emsp;&emsp;老醋花生,下锅前开水浸泡一个小时,过油酥,然后凉拌.口感香脆如油酥却又不上火. &emsp;&emsp;蒜苔腊肉,四川农家自制腊肉,食者方知其味美,非是流水线上的货色可比. &emsp;&emsp;凉拌猪耳朵,脆嫩可口. &emsp;&emsp;四川酱肉,腌制肉品,需大火煮透方可.味咸,易于长存.喝啤酒带着这货是个不错的选择,含肉,一大口啤酒,三两下一瓶便可下肚.对于不喜啤酒又得喝的同学来说是个不错的选择. &emsp;&emsp;凉拌折耳根,鲜嫩的折耳根(学名鱼腥草,是一味中药),去皮的莴苣切丝,浇上透亮的红油,又是一到美味.但这美味非是人人都能享受.其入口有特殊的腥味.折耳根尚未烹调前: &emsp;&emsp;最后,是重点推荐的四川腊肠.&emsp;&emsp;腊肠一般是在冬月期间灌制,有风干和qiu制(四川方言,非明火烟熏)两种,据说这期间制作的腊肉,腊肠,酱肉和罐罐肉口味最佳.在帝都走访多家超市,菜市,都未寻得味美的腊肠,终是和川味腊肠相距甚远.时节,水土对美食真的是颇有影响. &emsp;&emsp;四川腊肠尚未烹调前色偏深,蒸煮后色泽艳亮,显现出辣椒的红艳本色,让人垂涎.其吃法颇为丰富,最传统的是蒸煮后切片摆盘.煮过腊肠的汤水也不浪费,下上几块大白萝卜亦是美味.&emsp;&emsp;慵懒之时,用微波炉蒸上一碗米饭,起锅之前,覆上一层腊肠切片,继续中火烹调,出锅之后定是香气逼人,诱人垂涎. 西蜀雨城,好山好水养一方人;桌台灶前,千古传承留一席美味. P.S. 未经许可,不得转载.今生唯爱与美食不可辜负.","content":"<p>&emsp;&emsp;四川素有天府之国的美称,川菜更是在中华八大菜系中颇具影响力.天府之人,在骨子中都透露着对美食的追求,寻常百姓的家常饭亦是美味连连.华夏儿女不论富贵贫贱,年间总会摆上桌味美的年饭,和亲朋相聚.西蜀雨城一席年饭,欲与众人分享.<br><a id=\"more\"></a><br><img src=\"https://ww4.sinaimg.cn/large/6816152bgw1epf17kgkzyj21kw2t47v7.jpg\" alt=\"其中一桌\"><br>&emsp;&emsp;其中一桌.</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/6816152bgw1epf1acxgruj21kw0w0qal.jpg\" alt=\"泡脚凤爪\"><br>&emsp;&emsp;<strong>泡脚凤爪</strong>,个大肉多(传说中的荤泡菜).</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/6816152bgw1epf1bmasquj21kw0w0tgx.jpg\" alt=\"老醋花生\"><br>&emsp;&emsp;<strong>老醋花生</strong>,下锅前开水浸泡一个小时,过油酥,然后凉拌.口感香脆如油酥却又不上火.</p>\n<p><img src=\"https://ww1.sinaimg.cn/large/6816152bgw1epf1ekqulvj21kw0w0452.jpg\" alt=\"蒜苔腊肉\"><br>&emsp;&emsp;<strong>蒜苔腊肉</strong>,四川农家自制腊肉,食者方知其味美,非是流水线上的货色可比.</p>\n<p><img src=\"https://ww3.sinaimg.cn/large/6816152bjw1epf1jyf05gj21kw0w00zz.jpg\" alt=\"凉拌猪耳朵\"><br>&emsp;&emsp;<strong>凉拌猪耳朵</strong>,脆嫩可口.</p>\n<p><img src=\"https://ww4.sinaimg.cn/large/6816152bjw1epf1l16uhjj21kw0w0dlr.jpg\" alt=\"四川酱肉\"><br>&emsp;&emsp;<strong>四川酱肉</strong>,腌制肉品,需大火煮透方可.味咸,易于长存.喝啤酒带着这货是个不错的选择,含肉,一大口啤酒,三两下一瓶便可下肚.对于不喜啤酒又得喝的同学来说是个不错的选择.</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/6816152bgw1epf1glhyitj21kw0w0dnu.jpg\" alt=\"凉拌折耳根\"><br>&emsp;&emsp;<strong>凉拌折耳根</strong>,鲜嫩的折耳根(学名鱼腥草,是一味中药),去皮的莴苣切丝,浇上透亮的红油,又是一到美味.但这美味非是人人都能享受.其入口有特殊的腥味.折耳根尚未烹调前:<br><img src=\"https://ww1.sinaimg.cn/large/6816152bgw1epf1gzoc75j21kw0w0agd.jpg\" alt=\"鲜嫩折耳根\"></p>\n<p>&emsp;&emsp;最后,是重点推荐的<strong>四川腊肠</strong>.<br>&emsp;&emsp;<strong>腊肠</strong>一般是在冬月期间灌制,有风干和qiu制(四川方言,非明火烟熏)两种,据说这期间制作的腊肉,腊肠,酱肉和罐罐肉口味最佳.在帝都走访多家超市,菜市,都未寻得味美的腊肠,终是和川味腊肠相距甚远.时节,水土对美食真的是颇有影响.</p>\n<p><img src=\"https://ww2.sinaimg.cn/large/6816152bjw1epf1wmt9x9j21kw0w0tey.jpg\" alt=\"川味腊肠\"><br><img src=\"https://ww2.sinaimg.cn/large/6816152bjw1epf1x03db4j21kw0w0jwv.jpg\" alt=\"川味腊肠\"><br>&emsp;&emsp;四川腊肠尚未烹调前色偏深,蒸煮后色泽艳亮,显现出辣椒的红艳本色,让人垂涎.其吃法颇为丰富,最传统的是蒸煮后切片摆盘.煮过腊肠的汤水也不浪费,下上几块大白萝卜亦是美味.<br>&emsp;&emsp;慵懒之时,用微波炉蒸上一碗米饭,起锅之前,覆上一层腊肠切片,继续中火烹调,出锅之后定是香气逼人,诱人垂涎.</p>\n<p>西蜀雨城,好山好水养一方人;桌台灶前,千古传承留一席美味.</p>\n<p>P.S. 未经许可,不得转载.今生唯爱与美食不可辜负.</p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"&emsp;&emsp;四川素有天府之国的美称,川菜更是在中华八大菜系中颇具影响力.天府之人,在骨子中都透露着对美食的追求,寻常百姓的家常饭亦是美味连连.华夏儿女不论富贵贫贱,年间总会摆上桌味美的年饭,和亲朋相聚.西蜀雨城一席年饭,欲与众人分享.","categories":[{"name":"浮生","slug":"浮生","permalink":"//blog.kongfanjian.com/categories/浮生/"}],"tags":[{"name":"美食","slug":"美食","permalink":"//blog.kongfanjian.com/tags/美食/"},{"name":"西蜀","slug":"西蜀","permalink":"//blog.kongfanjian.com/tags/西蜀/"}]},{"title":"Refresh Project Folders Hotkey of Sublime Text 2,build 2221","date":"2015-02-03T05:25:39.000Z","path":"2015/02/03/Refresh-Project-Folder-Hotkey-of-Sublime-Text-2-build-2221/","text":"&emsp;&emsp;Sublime Text is a sophisticated text editor for code.I use it on Windows and OS X.But,the the problem I have with it of Version 2.0.2(Build 2221,OS X Yosemite),is that the project folder does not auto refresh when I add new files or folders that were created.&emsp;&emsp;You can manually refresh the folders,but it’s not efficient.We can set up a hotkey to do the work. Open Sublime Text. Select Preferences form the the top menu and then open Key Bindings – Default Go to the end of the file add add a comma to the last entry. Add the following entry:12// Refresh folder list with super+shift+r&#123; \"keys\": [\"super+shift+r\"], \"command\": \"refresh_folder_list\" &#125; &emsp;&emsp;Now all you have to to is save the file and enjoy with this hotkey( + + R) to refresh your project!&emsp;&emsp;Okay.In fact,this post is copy from Michael’s blog,but I don’t like use F5 on the Mac Book Pro.So, I changed the hotkey value to Super + shift + R. If you want to change the hotkey, simply switch [“super+shift+r″] for another value.","content":"<p>&emsp;&emsp;Sublime Text is a sophisticated text editor for code.I use it on Windows and OS X.But,the the problem I have with it of Version 2.0.2(Build 2221,OS X Yosemite),is that the project folder does not auto refresh when I add new files or folders that were created.<br><a id=\"more\"></a><br>&emsp;&emsp;You can manually refresh the folders,but it’s not efficient.We can set up a hotkey to do the work.</p>\n<ol>\n<li>Open Sublime Text.</li>\n<li>Select <strong>Preferences</strong> form the the top menu and then open <strong>Key Bindings – Default</strong> </li>\n<li>Go to the end of the file add add a comma to the last entry.</li>\n<li>Add the following entry:<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Refresh folder list with super+shift+r</span></div><div class=\"line\">&#123; <span class=\"string\">\"keys\"</span>: [<span class=\"string\">\"super+shift+r\"</span>], <span class=\"string\">\"command\"</span>: <span class=\"string\">\"refresh_folder_list\"</span> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>&emsp;&emsp;Now all you have to to is save the file and enjoy with this hotkey(<img src=\"http://km.support.apple.com/library/APPLE/APPLECARE_ALLGEOS/HT1343/ks_command.gif\" alt=\"\"> + <img src=\"http://km.support.apple.com/library/APPLE/APPLECARE_ALLGEOS/HT1343/ks_shift.gif\" alt=\"\"> + R) to refresh your project!<br>&emsp;&emsp;Okay.In fact,this post is copy from <a href=\"http://michael1e.com/sublime-text-refresh-folder-hotkey/\" target=\"_blank\" rel=\"external\">Michael’s blog</a>,but I don’t like use <strong>F5</strong> on the Mac Book Pro.So, I changed the hotkey value to <strong>Super + shift + R</strong>. If you want to change the hotkey, simply switch [“super+shift+r″] for another value.</p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"&emsp;&emsp;Sublime Text is a sophisticated text editor for code.I use it on Windows and OS X.But,the the problem I have with it of Version 2.0.2(Build 2221,OS X Yosemite),is that the project folder does not auto refresh when I add new files or folders that were created.","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"}],"tags":[{"name":"编辑器","slug":"编辑器","permalink":"//blog.kongfanjian.com/tags/编辑器/"},{"name":"hotkey","slug":"hotkey","permalink":"//blog.kongfanjian.com/tags/hotkey/"}]},{"title":"golang解析html模板到字符串","date":"2015-01-29T16:05:22.000Z","path":"2015/01/30/golang解析html模板到字符串/","text":"&emsp;&emsp;说来自己对golang的掌握也就半壶水,不过我向来认为学习就是一个不断踩坑的过程.只有在实践中才能不断的取得进步.最近在独力编写golang版本的影梭管理面板,其中有个需求就是给用户发送激活邮件,本着尽善尽美的原则,计划提供可编辑的html邮件模板.那么,问题就来了.使用html/template包对html模板进行解析,但是Execute函数是输出到io.Writer,而我需要的是把模板解析结果保存到string类型的变量中,以便直接传送给下一步负责发送邮件的函数使用.&emsp;&emsp;在网络上查阅资料后得知实现上述要求方法非常简单,只需要设置一个bytes.Buffer,Execute的时候把数据写入到这个缓存器当中,再调用String方法转换成字符串即可.&emsp;&emsp;Don’t talk,show me code!So,there is a sample: 123456789101112131415161718192021222324package mainimport ( \"html/template\" \"bytes\" \"fmt\")type Mail struct &#123; UserName string SiteName string ActiveLink string&#125;func main() &#123; var doc bytes.Buffer var templateString = \"&#123;&amp;#123;.UserName&#125;&#125;你好,您在&#123;&amp;#123;.SiteName&#125;&#125;注册了帐号,请点&lt;a href=\\\"&#123;&amp;#123;.ActiveLink&#125;&#125;\\\"&gt;击这里激活!&lt;/a&gt;\" t := template.New(\"fieldname example\") t, _ = t.Parse(templateString) p := Mail&#123;UserName: \"Frank\",SiteName: \"SSP\", ActiveLink: \"http://xizhimen.com/active/9a32f2\"&#125; t.Execute(&amp;doc,p) html := doc.String() fmt.Println(html)&#125; &emsp;&emsp;Sweet dream,Frank. 参考文献: [1] Package template [2] Package bytes #Buffer.string [3] Make template.Execute write output to a string","content":"<p>&emsp;&emsp;说来自己对golang的掌握也就半壶水,不过我向来认为学习就是一个不断踩坑的过程.只有在实践中才能不断的取得进步.最近在独力编写golang版本的影梭管理面板,其中有个需求就是给用户发送激活邮件,本着尽善尽美的原则,计划提供可编辑的html邮件模板.那么,问题就来了.使用<code>html/template</code>包对html模板进行解析,但是<code>Execute</code>函数是输出到<code>io.Writer</code>,而我需要的是把模板解析结果保存到<code>string</code>类型的变量中,以便直接传送给下一步负责发送邮件的函数使用.<a id=\"more\"></a><br>&emsp;&emsp;在网络上查阅资料后得知实现上述要求方法非常简单,只需要设置一个<code>bytes.Buffer</code>,<code>Execute</code>的时候把数据写入到这个缓存器当中,再调用<code>String</code>方法转换成字符串即可.<br>&emsp;&emsp;Don’t talk,show me code!So,there is a sample:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">package</span> main</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">import</span> (</div><div class=\"line\">    <span class=\"string\">\"html/template\"</span></div><div class=\"line\">    <span class=\"string\">\"bytes\"</span></div><div class=\"line\">    <span class=\"string\">\"fmt\"</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">type</span> Mail <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">    UserName <span class=\"keyword\">string</span></div><div class=\"line\">    SiteName <span class=\"keyword\">string</span></div><div class=\"line\">    ActiveLink <span class=\"keyword\">string</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> doc bytes.Buffer</div><div class=\"line\">    <span class=\"keyword\">var</span> templateString = <span class=\"string\">\"&#123;&amp;#123;.UserName&#125;&#125;你好,您在&#123;&amp;#123;.SiteName&#125;&#125;注册了帐号,请点&lt;a href=\\\"&#123;&amp;#123;.ActiveLink&#125;&#125;\\\"&gt;击这里激活!&lt;/a&gt;\"</span></div><div class=\"line\">    t := template.New(<span class=\"string\">\"fieldname example\"</span>)</div><div class=\"line\">    t, _ = t.Parse(templateString)</div><div class=\"line\">    p := Mail&#123;UserName: <span class=\"string\">\"Frank\"</span>,SiteName: <span class=\"string\">\"SSP\"</span>, ActiveLink: <span class=\"string\">\"http://xizhimen.com/active/9a32f2\"</span>&#125;</div><div class=\"line\">    t.Execute(&amp;doc,p)</div><div class=\"line\">    html := doc.String()</div><div class=\"line\">    fmt.Println(html)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>&emsp;&emsp;Sweet dream,Frank.</p>\n<p>参考文献:</p>\n<p>[1] <a href=\"http://golang.org/pkg/html/template/\" target=\"_blank\" rel=\"external\">Package template</a></p>\n<p>[2] <a href=\"http://golang.org/pkg/bytes/#Buffer.String\" target=\"_blank\" rel=\"external\">Package bytes #Buffer.string</a></p>\n<p>[3] <a href=\"https://groups.google.com/forum/#!topic/golang-nuts/dSFHCV-e6Nw\" target=\"_blank\" rel=\"external\">Make template.Execute write output to a string</a></p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"&emsp;&emsp;说来自己对golang的掌握也就半壶水,不过我向来认为学习就是一个不断踩坑的过程.只有在实践中才能不断的取得进步.最近在独力编写golang版本的影梭管理面板,其中有个需求就是给用户发送激活邮件,本着尽善尽美的原则,计划提供可编辑的html邮件模板.那么,问题就来了.使用html/template包对html模板进行解析,但是Execute函数是输出到io.Writer,而我需要的是把模板解析结果保存到string类型的变量中,以便直接传送给下一步负责发送邮件的函数使用.","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"},{"name":"golang","slug":"术业/golang","permalink":"//blog.kongfanjian.com/categories/术业/golang/"}],"tags":[{"name":"golang","slug":"golang","permalink":"//blog.kongfanjian.com/tags/golang/"}]},{"title":"boot2docker共享目录unicode文件名支持问题修复","date":"2015-01-22T17:08:03.000Z","path":"2015/01/23/boot2docker共享目录unicode文件名支持问题修复/","text":"&emsp;&emsp;这是一篇补记,问题在两周之前就已经解决了,并且给官方发送了pull request.目前官方只是把这个PR添加到了v1.5.0版的milestone当中,如果你需要.可以看我fork修改后的代码,或者直接下载生成好的ISO镜像. 0x1 问题&emsp;&emsp;Docker是个非常不错的工具,但是源于其本身的实现原理(依赖于Linux的LXC)的原因,Windows和OS X系统的用户是没有办法使用原生的docker的.幸运的是,docker官方为我们这一类非Linux用户提供了一个很好的工具——boot2docker.&emsp;&emsp;正如官方项目描述所言,boot2docker实质就是一个轻量级的支持Docker的Linux系统,事实上它就是基于Tiny Core Linux这一五脏俱全的小麻雀定制而成的.boot2docker虽是好用,但是在实际运用当中我却遇到了麻烦:boot2docker中的容器无法正常处理文件名使用unicode编码的文件的问题(注意:是文件名编码为unicode,而不是文件内容).&emsp;&emsp;或者简单点说,这个问题就是boot2docker中无法显示(ls -al)出自动挂载的VBox共享目录中的中文文件名的文件. 0x2 溯源&emsp;&emsp;存在即合理,既然必须要在docker容器当中处理中文文件名的文件,那么这个问题就应该解决掉.找准病因,才能对症下药.面对困难我们应当大胆假设,小心求证.&emsp;&emsp;首先怀疑是docker官方提供的image不支持中文,启动一个容器使用locale查看系统默认编码并不是GBK或者UTF-8.&emsp;&emsp;回想起来,当时这个假设还是相当的粗放,大胆的,根本没有仔细思考为什么是不显示文件而非文件名乱码.无知无畏,既然有了假设,不管这个假设正确与否,只有实践验证方知结果.通过localedef生成中文locale文件,并设置系统默认编码集为UTF-8.&emsp;&emsp;但是,结果还是让人让人失望的,依然无法显示中文名的文件.&emsp;&emsp;既然在容器中修改系统编码,同样是无法列出中文名的文件.那只能猜测是boot2docker这个轻量级的Linux系统存在问题了.&emsp;&emsp;通过ssh登录到boot2docker,在Home目录当中创建和查看中文名文件,验证了boot2docker本身是能够处理中文名文件的.而在VBox挂载进来的共享目录当中却是不能正常处理中文名文件.这说明问题是出在了boot2docker挂载共享目录这一环节. 0x3 除病&emsp;&emsp;既然找到了病症所在,那我们就能够开始下药方了.通过阅读boot2docker代码得知,它是使用rootfs/rootfs/etc/rc.d/automount-shares这一脚本自动挂载共享目录的.脚本中核心函数如下: 12345678910111213141516171819# try mounting \"$name\" (which defaults to \"$dir\") at \"$dir\",# but quietly clean up empty directories if it failstry_mount_share() &#123; dir=\"$1\" name=\"$&#123;2:-$dir&#125;\" mkdir -p \"$dir\" 2&gt;/dev/null if ! mount -t vboxsf -o \"$mountOptions\" \"$name\" \"$dir\" 2&gt;/dev/null; then rmdir \"$dir\" 2&gt;/dev/null || true while [ \"$(dirname \"$dir\")\" != \"$dir\" ]; do dir=\"$(dirname \"$dir\")\" rmdir \"$dir\" 2&gt;/dev/null || break done return 1 fi return 0&#125; &emsp;&emsp;boot2docker是基于Tiny Core Linux构建的,而Tiny Core Linux的rootfs是使用busybox构建的.并且Tiny Core Linux中mount工具源自busybox工具集,挂载共享目录时的默认编码并非UTF-8,这就导致了在宿主机中使用UTF-8编码的中文名文件挂载进boot2docker后无法显示出来.&emsp;&emsp;幸运的是,boot2docker集成了VBox的Gust Additions,其中包含了共享目录的专用挂载工具mount.vboxsf.我们可以通过mount.vboxsf的参数iocharset来设定挂载共享目录的编码集为UTF-8.修改后的shell脚本代码如下:12345678910111213141516171819# try mounting \"$name\" (which defaults to \"$dir\") at \"$dir\",# but quietly clean up empty directories if it failstry_mount_share() &#123; dir=\"$1\" name=\"$&#123;2:-$dir&#125;\" mkdir -p \"$dir\" 2&gt;/dev/null if ! mount.vboxsf -o \"$mountOptions\" \"$name\" \"$dir\" 2&gt;/dev/null; then rmdir \"$dir\" 2&gt;/dev/null || true while [ \"$(dirname \"$dir\")\" != \"$dir\" ]; do dir=\"$(dirname \"$dir\")\" rmdir \"$dir\" 2&gt;/dev/null || break done return 1 fi return 0&#125; &emsp;&emsp;最后,让我们一起来看一下是使用修改了automount-shares的boot2docker中对中文名文件的支持情况:&emsp;&emsp;目前已经能够显示中文名文件,虽然是乱码,但是并不影响容器当中处理文件. 0x4 结语&emsp;&emsp;通过boot2docker的Dockfile来构建镜像是比较耗费资源的,而且由于大陆网络的原因,还有可能无法下载构建过程中的某些包.为了方便大家使用,我在本地重新构建了一个修改自动挂载脚本后的boot2docker的ISO镜像上传到了百度网盘.下载地址:共享目录支持中文文件名的boot2dokcer镜像密码: 5qoc","content":"<p>&emsp;&emsp;这是一篇补记,问题在两周之前就已经解决了,并且给官方发送了pull request.目前官方只是把这个PR添加到了v1.5.0版的milestone当中,如果你需要.可以看我fork修改后的代码,或者直接下载生成好的<a href=\"http://pan.baidu.com/s/1hqKiLgw\" target=\"_blank\" rel=\"external\">ISO镜像</a>.</p>\n<h3 id=\"0x1-问题\"><a href=\"#0x1-问题\" class=\"headerlink\" title=\"0x1 问题\"></a>0x1 问题</h3><p>&emsp;&emsp;Docker是个非常不错的工具,但是源于其本身的实现原理(依赖于Linux的LXC)的原因,Windows和OS X系统的用户是没有办法使用原生的docker的.幸运的是,docker官方为我们这一类<code>非Linux用户</code>提供了一个很好的工具——boot2docker.<a id=\"more\"></a><br>&emsp;&emsp;正如官方项目描述所言,boot2docker实质就是一个轻量级的支持Docker的Linux系统,事实上它就是基于<code>Tiny Core Linux</code>这一五脏俱全的小麻雀定制而成的.boot2docker虽是好用,但是在实际运用当中我却遇到了麻烦:boot2docker中的容器无法正常处理文件名使用unicode编码的文件的问题(注意:是文件名编码为unicode,而不是文件内容).<br>&emsp;&emsp;或者简单点说,这个问题就是boot2docker中无法显示(<code>ls -al</code>)出自动挂载的VBox共享目录中的中文文件名的文件.</p>\n<h3 id=\"0x2-溯源\"><a href=\"#0x2-溯源\" class=\"headerlink\" title=\"0x2 溯源\"></a>0x2 溯源</h3><p>&emsp;&emsp;存在即合理,既然必须要在docker容器当中处理中文文件名的文件,那么这个问题就应该解决掉.找准病因,才能对症下药.面对困难我们应当大胆假设,小心求证.<br>&emsp;&emsp;首先怀疑是docker官方提供的image不支持中文,启动一个容器使用<code>locale</code>查看系统默认编码并不是GBK或者UTF-8.<br><img src=\"https://ww2.sinaimg.cn/large/6816152bgw1eojcme1s2rj20fa0a6dgp.jpg\" alt=\"docker CentOS 默认编码\"><br>&emsp;&emsp;回想起来,当时这个假设还是相当的粗放,大胆的,根本没有仔细思考为什么是<code>不显示文件</code>而非<code>文件名乱码</code>.无知无畏,既然有了假设,不管这个假设正确与否,只有实践验证方知结果.通过<code>localedef</code>生成中文locale文件,并设置系统默认编码集为UTF-8.<br><img src=\"https://ww2.sinaimg.cn/large/6816152bgw1eojce2nyzrj20fa0a6dh1.jpg\" alt=\"修改系统locale和编码集\"><br>&emsp;&emsp;但是,结果还是让人让人失望的,依然无法显示中文名的文件.<br><img src=\"https://ww3.sinaimg.cn/large/6816152bgw1eojedcbf5kj20nu05wgm9.jpg\" alt=\"试验失败\"><br>&emsp;&emsp;既然在容器中修改系统编码,同样是无法列出中文名的文件.那只能猜测是boot2docker这个轻量级的Linux系统存在问题了.<br><img src=\"https://ww1.sinaimg.cn/large/6816152bgw1eojek6sk49j20nu0ci0uy.jpg\" alt=\"boot2docker中无法列出VBox共享目录中的中文文件\"><br>&emsp;&emsp;通过ssh登录到boot2docker,在Home目录当中创建和查看中文名文件,验证了boot2docker本身是能够处理中文名文件的.而在VBox挂载进来的共享目录当中却是不能正常处理中文名文件.这说明问题是出在了boot2docker挂载共享目录这一环节.<br><img src=\"https://ww4.sinaimg.cn/large/6816152bgw1eojez26e6yj20cf05it95.jpg\" alt=\"在boot2docker的home目录中测试中文名文件\"></p>\n<h3 id=\"0x3-除病\"><a href=\"#0x3-除病\" class=\"headerlink\" title=\"0x3 除病\"></a>0x3 除病</h3><p>&emsp;&emsp;既然找到了病症所在,那我们就能够开始下药方了.通过阅读boot2docker代码得知,它是使用<code>rootfs/rootfs/etc/rc.d/automount-shares</code>这一脚本自动挂载共享目录的.脚本中核心函数如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># try mounting \"$name\" (which defaults to \"$dir\") at \"$dir\",</span></div><div class=\"line\"><span class=\"comment\"># but quietly clean up empty directories if it fails</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">try_mount_share</span></span>() &#123;</div><div class=\"line\">\tdir=<span class=\"string\">\"<span class=\"variable\">$1</span>\"</span></div><div class=\"line\">\tname=<span class=\"string\">\"<span class=\"variable\">$&#123;2:-$dir&#125;</span>\"</span></div><div class=\"line\">\t</div><div class=\"line\">\tmkdir -p <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> 2&gt;/dev/null</div><div class=\"line\">\t<span class=\"keyword\">if</span> ! mount -t vboxsf -o <span class=\"string\">\"<span class=\"variable\">$mountOptions</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$name</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> 2&gt;/dev/null; <span class=\"keyword\">then</span></div><div class=\"line\">\t\trmdir <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> 2&gt;/dev/null || <span class=\"literal\">true</span></div><div class=\"line\">\t\t<span class=\"keyword\">while</span> [ <span class=\"string\">\"<span class=\"variable\">$(dirname \"$dir\")</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> ]; <span class=\"keyword\">do</span></div><div class=\"line\">\t\t\tdir=<span class=\"string\">\"<span class=\"variable\">$(dirname \"$dir\")</span>\"</span></div><div class=\"line\">\t\t\trmdir <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> 2&gt;/dev/null || <span class=\"built_in\">break</span></div><div class=\"line\">\t\t<span class=\"keyword\">done</span></div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"built_in\">return</span> 1</div><div class=\"line\">\t<span class=\"keyword\">fi</span></div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"built_in\">return</span> 0</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>&emsp;&emsp;boot2docker是基于<code>Tiny Core Linux</code>构建的,而Tiny Core Linux的rootfs是使用<code>busybox</code>构建的.并且Tiny Core Linux中mount工具源自busybox工具集,挂载共享目录时的默认编码并非UTF-8,这就导致了在宿主机中使用UTF-8编码的中文名文件挂载进boot2docker后无法显示出来.<br>&emsp;&emsp;幸运的是,boot2docker集成了VBox的Gust Additions,其中包含了共享目录的专用挂载工具<code>mount.vboxsf</code>.我们可以通过<code>mount.vboxsf</code>的参数<code>iocharset</code>来设定挂载共享目录的编码集为UTF-8.修改后的shell脚本代码如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># try mounting \"$name\" (which defaults to \"$dir\") at \"$dir\",</span></div><div class=\"line\"><span class=\"comment\"># but quietly clean up empty directories if it fails</span></div><div class=\"line\"><span class=\"function\"><span class=\"title\">try_mount_share</span></span>() &#123;</div><div class=\"line\">\tdir=<span class=\"string\">\"<span class=\"variable\">$1</span>\"</span></div><div class=\"line\">\tname=<span class=\"string\">\"<span class=\"variable\">$&#123;2:-$dir&#125;</span>\"</span></div><div class=\"line\">\t</div><div class=\"line\">\tmkdir -p <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> 2&gt;/dev/null</div><div class=\"line\">\t<span class=\"keyword\">if</span> ! mount.vboxsf -o <span class=\"string\">\"<span class=\"variable\">$mountOptions</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$name</span>\"</span> <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> 2&gt;/dev/null; <span class=\"keyword\">then</span></div><div class=\"line\">\t\trmdir <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> 2&gt;/dev/null || <span class=\"literal\">true</span></div><div class=\"line\">\t\t<span class=\"keyword\">while</span> [ <span class=\"string\">\"<span class=\"variable\">$(dirname \"$dir\")</span>\"</span> != <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> ]; <span class=\"keyword\">do</span></div><div class=\"line\">\t\t\tdir=<span class=\"string\">\"<span class=\"variable\">$(dirname \"$dir\")</span>\"</span></div><div class=\"line\">\t\t\trmdir <span class=\"string\">\"<span class=\"variable\">$dir</span>\"</span> 2&gt;/dev/null || <span class=\"built_in\">break</span></div><div class=\"line\">\t\t<span class=\"keyword\">done</span></div><div class=\"line\">\t\t</div><div class=\"line\">\t\t<span class=\"built_in\">return</span> 1</div><div class=\"line\">\t<span class=\"keyword\">fi</span></div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"built_in\">return</span> 0</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>&emsp;&emsp;最后,让我们一起来看一下是使用修改了<code>automount-shares</code>的boot2docker中对中文名文件的支持情况:<br><img src=\"https://ww4.sinaimg.cn/large/6816152bgw1eojium0q9qj20il0ci0uy.jpg\" alt=\"能够显示中文名文件,虽然是乱码\"><br>&emsp;&emsp;目前已经能够显示中文名文件,虽然是乱码,但是并不影响容器当中处理文件.</p>\n<h3 id=\"0x4-结语\"><a href=\"#0x4-结语\" class=\"headerlink\" title=\"0x4 结语\"></a>0x4 结语</h3><p>&emsp;&emsp;通过boot2docker的Dockfile来构建镜像是比较耗费资源的,而且由于大陆网络的原因,还有可能无法下载构建过程中的某些包.为了方便大家使用,我在本地重新构建了一个修改自动挂载脚本后的boot2docker的ISO镜像上传到了百度网盘.<br>下载地址:<a href=\"http://pan.baidu.com/s/1hqKiLgw\" target=\"_blank\" rel=\"external\">共享目录支持中文文件名的boot2dokcer镜像</a><br>密码: 5qoc</p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"&emsp;&emsp;这是一篇补记,问题在两周之前就已经解决了,并且给官方发送了pull request.目前官方只是把这个PR添加到了v1.5.0版的milestone当中,如果你需要.可以看我fork修改后的代码,或者直接下载生成好的ISO镜像. 0x1 问题&emsp;&emsp;Docker是个非常不错的工具,但是源于其本身的实现原理(依赖于Linux的LXC)的原因,Windows和OS X系统的用户是没有办法使用原生的docker的.幸运的是,docker官方为我们这一类非Linux用户提供了一个很好的工具——boot2docker.","categories":[{"name":"术业","slug":"术业","permalink":"//blog.kongfanjian.com/categories/术业/"},{"name":"docker","slug":"术业/docker","permalink":"//blog.kongfanjian.com/categories/术业/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"//blog.kongfanjian.com/tags/docker/"},{"name":"boot2docker","slug":"boot2docker","permalink":"//blog.kongfanjian.com/tags/boot2docker/"}]},{"title":"岁末重逢","date":"2015-01-22T11:20:10.000Z","path":"2015/01/22/岁末重逢/","text":"&emsp;&emsp;从最开始使用网易的服务器,到租用虚拟主机,一直到购买VPS,粗略算来,之前写博客已有四年之久.唯有缺憾的确实这么长久的坚持,却是在13年出现了断档.现在重拾唯有唏嘘.&emsp;&emsp;浮生且短,又有几载春秋,可持之以恒的做一件事又何其艰难,敢问坚持之人几许?我如风中落叶四处飘零,处处短暂,只愿在此长留.&emsp;&emsp;之前所用域名kofj.net将做保留,但不再恢复备份数据;新站则是使用kongfanjian.com域名,页面托管在Github Pages.这样,我讲能够省却不少时间和精力,专注在文章本上之上.&emsp;&emsp;最后,感谢所用程序的作者Tommy Chen以及主题yilia作者Litten.以及那个她.甲午年冬月","content":"<p>&emsp;&emsp;从最开始使用网易的服务器,到租用虚拟主机,一直到购买VPS,粗略算来,之前写博客已有四年之久.唯有缺憾的确实这么长久的坚持,却是在13年出现了断档.现在重拾唯有唏嘘.<br><a id=\"more\"></a><br>&emsp;&emsp;浮生且短,又有几载春秋,可持之以恒的做一件事又何其艰难,敢问坚持之人几许?我如风中落叶四处飘零,处处短暂,只愿在此长留.<br>&emsp;&emsp;之前所用域名<code>kofj.net</code>将做保留,但不再恢复备份数据;新站则是使用<code>kongfanjian.com</code>域名,页面托管<code>在Github Pages</code>.这样,我讲能够省却不少时间和精力,专注在文章本上之上.<br>&emsp;&emsp;最后,感谢所用程序的作者<a href=\"https://github.com/tommy351\" target=\"_blank\" rel=\"external\">Tommy Chen</a>以及主题<code>yilia</code>作者<a href=\"https://github.com/litten/hexo-theme-yilia\" target=\"_blank\" rel=\"external\">Litten</a>.以及那个她.<br>甲午年冬月</p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"&emsp;&emsp;从最开始使用网易的服务器,到租用虚拟主机,一直到购买VPS,粗略算来,之前写博客已有四年之久.唯有缺憾的确实这么长久的坚持,却是在13年出现了断档.现在重拾唯有唏嘘.","categories":[{"name":"浮生","slug":"浮生","permalink":"//blog.kongfanjian.com/categories/浮生/"}],"tags":[{"name":"感言","slug":"感言","permalink":"//blog.kongfanjian.com/tags/感言/"},{"name":"随笔","slug":"随笔","permalink":"//blog.kongfanjian.com/tags/随笔/"}]},{"title":"蘭亭集序","date":"2015-01-22T08:48:46.000Z","path":"2015/01/22/兰亭集序/","text":"永和九年，歲在癸丑，暮春之初，會於會稽山陰之蘭亭，脩稧事也。羣賢畢至，少長咸集。此地有崇山峻領（嶺），茂林脩竹；又有清流激湍，映帶左右，引以為流觴曲水，列坐其次。雖無絲竹管弦之盛，一觴一詠，亦足以暢敘幽情。是日也，天朗氣清，惠風和暢。仰觀宇宙之大，俯察品類之盛。所以遊目騁懷，足以極視聽之娛，信可樂也。夫人之相與，俯仰一世，或取諸懷抱，悟言一室之內；或因寄所託，放浪形骸之外。雖趣（取/趨）舍萬殊，靜躁不同，當其欣於所遇，暫得於己，怏然自足，不知老之將至；及其所之既倦，情隨事遷，感慨係之矣。向之所欣，俛仰之間，已為陳跡，猶不能不以之興懷；況脩短隨化，終期於盡。古人云：「死生亦大矣。」豈不痛哉！每攬（覽）昔人興感之由，若合一契，未嘗不臨文嗟悼，不能喻之於懷。固知一死生為虛誕，齊彭殤為妄作。後之視今，亦猶今之視昔，悲夫！故列敘時人，錄其所述，雖世殊事異，所以興懷，其致一也。後之攬（覽）者，亦將有感於斯文。","content":"<p>永和九年，歲在癸丑，暮春之初，會於會稽山陰之蘭亭，脩稧事也。羣賢畢至，少長咸集。此地有崇山峻領（嶺），茂林脩竹；又有清流激湍，映帶左右，引以為流觴曲水，列坐其次。雖無絲竹管弦之盛，一觴一詠，亦足以暢敘幽情。<br><a id=\"more\"></a><br>是日也，天朗氣清，惠風和暢。仰觀宇宙之大，俯察品類之盛。所以遊目騁懷，足以極視聽之娛，信可樂也。<br>夫人之相與，俯仰一世，或取諸懷抱，悟言一室之內；或因寄所託，放浪形骸之外。雖趣（取/趨）舍萬殊，靜躁不同，當其欣於所遇，暫得於己，怏然自足，不知老之將至；及其所之既倦，情隨事遷，感慨係之矣。向之所欣，俛仰之間，已為陳跡，猶不能不以之興懷；況脩短隨化，終期於盡。古人云：「死生亦大矣。」豈不痛哉！<br>每攬（覽）昔人興感之由，若合一契，未嘗不臨文嗟悼，不能喻之於懷。固知一死生為虛誕，齊彭殤為妄作。後之視今，亦猶今之視昔，悲夫！故列敘時人，錄其所述，雖世殊事異，所以興懷，其致一也。後之攬（覽）者，亦將有感於斯文。</p>\n","updated":"2016-12-13T03:14:31.000Z","excerpt":"永和九年，歲在癸丑，暮春之初，會於會稽山陰之蘭亭，脩稧事也。羣賢畢至，少長咸集。此地有崇山峻領（嶺），茂林脩竹；又有清流激湍，映帶左右，引以為流觴曲水，列坐其次。雖無絲竹管弦之盛，一觴一詠，亦足以暢敘幽情。","categories":[{"name":"诗词","slug":"诗词","permalink":"//blog.kongfanjian.com/categories/诗词/"}],"tags":[{"name":"古诗词","slug":"古诗词","permalink":"//blog.kongfanjian.com/tags/古诗词/"},{"name":"文言","slug":"文言","permalink":"//blog.kongfanjian.com/tags/文言/"}]}]